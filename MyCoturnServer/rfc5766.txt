  Traversal Using Relays around NAT (TURN):
     Relay Extensions to Session Traversal Utilities for NAT (STUN)

Abstract

   如果主机位于NAT后面，那么在某些情况下，
   该主机可能无法直接与其他主机（对等方）通信。 
   在这些情况下，主机必须使用充当通信中继的中间节点的服务。 
   该规范定义了一种称为TURN（遍历NAT的遍历）的协议，
   该协议允许主机控制中继的操作并使用中继与其对等体交换分组。 
   TURN与其他一些中继控制协议的不同之处在于它允许客户端使用单个中继地址与多个对等体通信。

本备忘录的状态

   这是Internet标准跟踪文档。
   本文档是Internet工程任务组的产品
  （IETF）。 它代表了IETF社区的共识。
   它已经过公众审查，并已获得互联网工程指导小组
  （IESG）的批准发布。 有关Internet标准的更多信息，请参见RFC 5741的第2节。

   有关本文档的当前状态，任何勘误以及如何提供反馈的信息，请访
   问http://www.rfc-editor.org/info/rfc5766。
   
版权声明

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  Overview of Operation  . . . . . . . . . . . . . . . . . . . .  5
     2.1.  Transports . . . . . . . . . . . . . . . . . . . . . . . .  8
     2.2.  Allocations  . . . . . . . . . . . . . . . . . . . . . . .  9
     2.3.  Permissions  . . . . . . . . . . . . . . . . . . . . . . . 11
     2.4.  Send Mechanism . . . . . . . . . . . . . . . . . . . . . . 12
     2.5.  Channels . . . . . . . . . . . . . . . . . . . . . . . . . 13
     2.6.  Unprivileged TURN Servers  . . . . . . . . . . . . . . . . 15
     2.7.  Avoiding IP Fragmentation  . . . . . . . . . . . . . . . . 16
     2.8.  RTP Support  . . . . . . . . . . . . . . . . . . . . . . . 17
     2.9.  Anycast Discovery of Servers . . . . . . . . . . . . . . . 17
   3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . 18
   4.  General Behavior . . . . . . . . . . . . . . . . . . . . . . . 19
   5.  Allocations  . . . . . . . . . . . . . . . . . . . . . . . . . 22
   6.  Creating an Allocation . . . . . . . . . . . . . . . . . . . . 23
     6.1.  Sending an Allocate Request  . . . . . . . . . . . . . . . 23
     6.2.  Receiving an Allocate Request  . . . . . . . . . . . . . . 24
     6.3.  Receiving an Allocate Success Response . . . . . . . . . . 28
     6.4.  Receiving an Allocate Error Response . . . . . . . . . . . 29
   7.  Refreshing an Allocation . . . . . . . . . . . . . . . . . . . 31
     7.1.  Sending a Refresh Request  . . . . . . . . . . . . . . . . 31
     7.2.  Receiving a Refresh Request  . . . . . . . . . . . . . . . 31
     7.3.  Receiving a Refresh Response . . . . . . . . . . . . . . . 32
   8.  Permissions  . . . . . . . . . . . . . . . . . . . . . . . . . 32
   9.  CreatePermission . . . . . . . . . . . . . . . . . . . . . . . 34
     9.1.  Forming a CreatePermission Request . . . . . . . . . . . . 34
     9.2.  Receiving a CreatePermission Request . . . . . . . . . . . 34
     9.3.  Receiving a CreatePermission Response  . . . . . . . . . . 35
   10. Send and Data Methods  . . . . . . . . . . . . . . . . . . . . 35
     10.1. Forming a Send Indication  . . . . . . . . . . . . . . . . 35
     10.2. Receiving a Send Indication  . . . . . . . . . . . . . . . 35 
     10.3. Receiving a UDP Datagram . . . . . . . . . . . . . . . . . 36
     10.4. Receiving a Data Indication  . . . . . . . . . . . . . . . 37
   11. Channels . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
     11.1. Sending a ChannelBind Request  . . . . . . . . . . . . . . 39
     11.2. Receiving a ChannelBind Request  . . . . . . . . . . . . . 39
     11.3. Receiving a ChannelBind Response . . . . . . . . . . . . . 40
     11.4. The ChannelData Message  . . . . . . . . . . . . . . . . . 41
     11.5. Sending a ChannelData Message  . . . . . . . . . . . . . . 41
     11.6. Receiving a ChannelData Message  . . . . . . . . . . . . . 42
     11.7. Relaying Data from the Peer  . . . . . . . . . . . . . . . 43
   12. IP Header Fields . . . . . . . . . . . . . . . . . . . . . . . 43
   13. New STUN Methods . . . . . . . . . . . . . . . . . . . . . . . 45
   14. New STUN Attributes  . . . . . . . . . . . . . . . . . . . . . 45
     14.1. CHANNEL-NUMBER . . . . . . . . . . . . . . . . . . . . . . 45
     14.2. LIFETIME . . . . . . . . . . . . . . . . . . . . . . . . . 46
     14.3. XOR-PEER-ADDRESS . . . . . . . . . . . . . . . . . . . . . 46
     14.4. DATA . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
     14.5. XOR-RELAYED-ADDRESS  . . . . . . . . . . . . . . . . . . . 46
     14.6. EVEN-PORT  . . . . . . . . . . . . . . . . . . . . . . . . 46
     14.7. REQUESTED-TRANSPORT  . . . . . . . . . . . . . . . . . . . 47
     14.8. DONT-FRAGMENT  . . . . . . . . . . . . . . . . . . . . . . 47
     14.9. RESERVATION-TOKEN  . . . . . . . . . . . . . . . . . . . . 48
   15. New STUN Error Response Codes  . . . . . . . . . . . . . . . . 48
   16. Detailed Example . . . . . . . . . . . . . . . . . . . . . . . 48
   17. Security Considerations  . . . . . . . . . . . . . . . . . . . 55
     17.1. Outsider Attacks . . . . . . . . . . . . . . . . . . . . . 55
       17.1.1.  Obtaining Unauthorized Allocations  . . . . . . . . . 55
       17.1.2.  Offline Dictionary Attacks  . . . . . . . . . . . . . 56
       17.1.3.  Faked Refreshes and Permissions . . . . . . . . . . . 56
       17.1.4.  Fake Data . . . . . . . . . . . . . . . . . . . . . . 56
       17.1.5.  Impersonating a Server  . . . . . . . . . . . . . . . 57
       17.1.6.  Eavesdropping Traffic . . . . . . . . . . . . . . . . 58
       17.1.7.  TURN Loop Attack  . . . . . . . . . . . . . . . . . . 58
     17.2. Firewall Considerations  . . . . . . . . . . . . . . . . . 59
       17.2.1.  Faked Permissions . . . . . . . . . . . . . . . . . . 59
       17.2.2.  Blacklisted IP Addresses  . . . . . . . . . . . . . . 60
       17.2.3.  Running Servers on Well-Known Ports . . . . . . . . . 60
     17.3. Insider Attacks  . . . . . . . . . . . . . . . . . . . . . 60
       17.3.1.  DoS against TURN Server . . . . . . . . . . . . . . . 60
       17.3.2.  Anonymous Relaying of Malicious Traffic . . . . . . . 61
       17.3.3.  Manipulating Other Allocations  . . . . . . . . . . . 61
     17.4. Other Considerations . . . . . . . . . . . . . . . . . . . 61
   18. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 61
   19. IAB Considerations . . . . . . . . . . . . . . . . . . . . . . 62
   20. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 63
   21. References . . . . . . . . . . . . . . . . . . . . . . . . . . 64
     21.1. Normative References . . . . . . . . . . . . . . . . . . . 64
     21.2. Informative References . . . . . . . . . . . . . . . . . . 64
	  
1.  Introduction

   NAT后面的主机可能希望与其他主机交换数据包，其中一些主机也可能在NAT之后。 
   为此，所涉及的主机可以使用“打孔”技术（参见[RFC5128]）
   尝试发现直接通信路径; 也就是说，
   通过介入NAT和路由器从一个主机到另一个主机的通信路径，但不会遍历任何中继。

   如[RFC5128]和[RFC4787]中所述，如果两个主机都位于表现不佳的NAT之后，则打孔技术将失败。
   例如，如果两个主机都位于具有“依赖于地址的映射”
   或“依赖于地址和端口的映射”的映射行为的NAT之后，则打孔技术通常会失败。
   
   当找不到直接通信路径时，必须使用充当分组中继的中间主机的服务。 
   此中继通常位于公共Internet中，并在两个位于NAT后面的主机之间中继数据包。

   该规范定义了一个名为TURN的协议，它允许NAT后面的主机（称为TURN客户端）请求另一个主机（称为TURN服务器）充当中继。
   客户端可以安排服务器将数据包中继到某些其他主机（称为对等端）和从某些其他主机（称为对等端）中继，
   并且可以控制如何完成中继的方面。
   客户端通过获取IP地址和端口来完成此操作服务器，称为中继传输地址。
   当对等体将分组发送到中继的传输地址时，服务器将分组中继到客户端。
   当客户端向服务器发送数据包时，服务器使用中继的传输地址作为源将其中继到适当的对等端。

   使用TURN的客户端必须有一些方法将中继的传输地址传递给其对等端，
   并且要了解每个对等方的IP地址和端口（更确切地说，每个对等方的服务器自反传输地址，请参阅第2节）。
   如何做到这一点超出了TURN协议的范围。
   可以做的一种方法是让客户端和对等端交换电子邮件消息。
   另一种方法是客户端及其对等方使用专用的“简介”或“会合”协议（有关详细信息，请参阅[RFC5128]）。

   如果TURN与ICE [RFC5245]一起使用，
   则中继的传输地址以及对等体的IP地址和端口在ICE候选信息中通过协议携带。

   例如，如果使用TURN和ICE作为使用SIP [RFC3261]的多媒体解决方案的一部分，
   则SIP服务于会合协议的角色，在SIP消息的主体内携带ICE候选信息。
   如果TURN和ICE与某些其他集合协议一起使用，
   则[MMUSIC-ICE-NONSIP]提供有关集合协议必须执行的服务的指导。
     
   尽管使用TURN服务器来实现NAT后面的两个主机之间的通信很可能会起作用，
   但是对于TURN服务器的提供商而言成本很高，因为服务器通常需要很大的带宽。
   
   因此，最好只在无法找到直接通信路径时才使用TURN服务器。
   当客户端和对等方使用ICE来确定通信路径时，
   ICE将首先使用打孔技术来搜索直接路径，
   并且在找不到直接路径时仅使用TURN服务器。

   TURN最初发明用于支持使用SIP发信号通知的多媒体会话。
   由于SIP支持分叉，因此TURN支持每个中继传输地址的多个对等：其他方法不支持的功能（例如，SOCKS [RFC1928]）。
   但是，TURN也适用于其他类型的应用。

   TURN在较大的ICE NAT穿越办法中被设计为一个部分。 
   敦促TURN的实施者对ICE进行调查，并认真考虑将其用于其应用。
   但是，可以在没有ICE的情况下使用TURN。

   TURN是STUN（NAT穿越通信的实用程序）协议[RFC5389]的扩展。 
   大多数（尽管不是全部）TURN消息是STUN格式的消息。 
   本文的读者应该熟悉STUN。

2.  Overview of Operation

   本节概述了TURN的操作。 这是非规范性的。

   在典型配置中，TURN客户端连接到专用网络[RFC1918]
   并通过一个或多个NAT连接到公共因特网。
   在公共Internet上是TURN服务器。
   互联网中的其他地方是TURN客户端希望与之通信的一个或多个对等体。
   这些对等体可能或可能不在一个或多个NAT后面。
   客户端使用服务器作为中继来向这些对等体发送数据包并从这些对等体接收数据包。
    
                                        Peer A
                                        Server-Reflexive    +---------+
                                        Transport Address   |         |
                                        192.0.2.150:32102   |         |
                                            |              /|         |
                          TURN              |            / ^|  Peer A |
    Client's              Server            |           /  ||         |
    Host Transport        Transport         |         //   ||         |
    Address               Address           |       //     |+---------+
   10.1.1.2:49721       192.0.2.15:3478     |+-+  //     Peer A
            |               |               ||N| /       Host Transport
            |   +-+         |               ||A|/        Address
            |   | |         |               v|T|     192.168.100.2:49582
            |   | |         |               /+-+
 +---------+|   | |         |+---------+   /              +---------+
 |         ||   |N|         ||         | //               |         |
 | TURN    |v   | |         v| TURN    |/                 |         |
 | Client  |----|A|----------| Server  |------------------|  Peer B |
 |         |    | |^         |         |^                ^|         |
 |         |    |T||         |         ||                ||         |
 +---------+    | ||         +---------+|                |+---------+
                | ||                    |                |
                | ||                    |                |
                +-+|                    |                |
                   |                    |                |
                   |                    |                |
             Client's                   |            Peer B
             Server-Reflexive    Relayed             Transport
             Transport Address   Transport Address   Address
             192.0.2.1:7000      192.0.2.15:50000     192.0.2.210:49191

                                 图1

   图1显示了典型部署。在此图中，TURN客户端和TURN服务器由NAT分隔，
   客户端位于私有端，服务器位于NAT的公共端。 
   在此图中，TURN客户端和TURN服务器由NAT分隔，客户端位于私有端，服务器位于NAT的公共端。
   客户端与服务器通信的组合（IP地址，端口）称为客户端的HOST TRANSPORT ADDRESS。
    (IP地址和端口的组合称为TRANSPORT ADDRESS。)

   客户端将TURN消息从其主机传输地址发送到TURN服务器上的传输地址，
   该地址称为TURN SERVER TRANSPORT ADDRESS。 
   客户端通过一些未指定的手段（例如，配置）得到TURN服务器传输地址，
   并且该地址通常由许多客户端同时使用。 
    
   由于客户端位于NAT后面，因此服务器将来自客户端的数据包视为来自NAT本身的传输地址。
   此地址称为客户端的SERVER-REFLEXIVE传输地址（就是客户端的外网地址）：
   服务器发送到客户端的外网地址的数据包将由NAT转发到客户端的内网地址。
   
   客户端使用TURN命令在服务器上创建和操作ALLOCATION。
   ALLOCATION是服务器上的数据结构。
   此数据结构包含用于分配的中继传输地址等。
   此数据结构包含用于中继传输地址（RELAYED TRANSPORT ADDRESS）等。
   中继传输地址是服务器上的传输地址，对等端可以使用该地址使服务器将数据中继到客户端。
   一个Allocation操作用它的中继地址作为唯一标识(端口). 

   一旦创建了allocation，客户端就可以向服务
   器发送应用程序数据以及指令数据将被发送到哪个对等体，
   并且服务器将该数据中继到适当的对等体。 

   客户端在TURN消息内将应用程序数据发送到服务器; 
   在服务器上，从TURN消息中提取数据并使用UDP将数据发送给对等端。
   在相反的方向上，对等端可以将UDP数据报文中的应用数据发送
   到allocation中的relayed transport address。
   然后，服务器将此数据封装在TURN消息中，并将其发送到客户端，
   同时指示哪个对等端发送了数据。
    
   由于TURN消息始终包含客户端与哪个对等端通信的指令，
   因此客户端可以使用一个allocation来与多个对等体通信。
   
   当对等体端于NAT后面时，客户端必须使用其外网地址而不是其内网地址来识别对等体。 
   
   例如，要在上面的示例中将应用程序数据发送到对等端A，
   客户端必须指定192.0.2.150:32102（对等端A的服务器外网地址）
   而不是192.168.100.2：49582（对等方A的内网地址）。
   服务器上的每个allocation都属于一个客户端，
   并且只有一个仅由该allocation使用的中继传输地址。     
   因此，当数据包到达服务器上的中继传输地址时，服务器知道数据是针对哪个客户端。  
   客户端可能同时在服务器上进行多个allocation。 
    
2.1.  网络传输方式

   如本规范中所定义的，TURN始终在服务器和对等体之间使用UDP。
   但是，此规范允许通过TCP使用UDP，TCP或TLS over TCP
   中的任何一个来在客户端和服务器之间传送TURN消息。 

           +----------------------------+---------------------+
           | TURN client to TURN server | TURN server to peer |
           +----------------------------+---------------------+
           |             UDP            |         UDP         |
           |             TCP            |         UDP         |
           |        TLS over TCP        |         UDP         |
           +----------------------------+---------------------+

   如果在客户端和服务器之间使用TCP或TLS-over-TCP，
   然后，当向对等端发送数据时，服务器将在这些传输和UDP传输之间进行转换。
    
   由于此版本的TURN仅支持服务器和对等体之间的UDP，
   预计大多数客户端也会更亲相遇在客户端和服务器之间使用UDP。
   在这种情况下，一些读者可能会想：为什么还支持TCP和TLS-over-TCP？

   TURN支持客户端和服务器之间的TCP传输，因为某些防火墙配置为完全阻止UDP。
   这些防火墙阻止UDP但不阻止TCP，部分原因是防火墙比较亲相遇使用TCP。 

   例如，TCP具有三次握手，更清楚地表明受保护节点确实希望建立该特定连接，
   而对于UDP，防火墙可以做的最好的事情就是通过使用过滤规则来猜测需要哪些流。     
   此外，TCP有明确的连接断开; 而对于UDP，防火墙必须使用计时器来猜测流程何时完成。
   TURN支持客户端和服务器之间的TLS-over-TCP传输，
   因为TLS提供了TURN默认身份验证所不能提供的其他安全属性。 
   某些客户可能希望利用的属性。     
   特别地，TLS为客户端提供了一种方法，以确定它正在与正确的服务器通信，并提供TURN控制消息的机密性。 
   
   TURN不需要TLS，因为使用TLS的开销高于tcp自带的认证的开销;  
   例如，使用TLS可能意味着大多数应用程序数据将被双重加密
  （一次通过TLS，一次确保它仍然在UDP数据报中加密）。
   TURN有计划的扩展，以在服务器和对等端之间添加对TCP的支持[TURN-TCP]。
   因此，在服务器和对等端之间使用UDP的allocation称为UDP allocation，
   而在服务器和对等体之间使用TCP的allocation称为TCP allocation。
  
   该规范仅描述UDP分配。

   如本说明书中所定义的，TURN仅支持IPv4。本规范中的地址必须是IPv4地址。
   TURN计划扩展以增加对IPv6的支持以及IPv4和IPv6之间的中继[TURN-IPv6]。

   在TURN的一些应用中，客户端可以在其用于与服务器通信的
   主机传输地址上发送和接收除TURN分组之外的数据包。
   例如，当使用TURN和ICE时会发生这种情况。

   在这些情况下，客户端可以通过检查到达数据包的源地址来区分TURN数据包和其他数据包：
   从TURN服务器到达的那些将是TURN包。

2.2.  Allocations

   要在服务器上创建Allocate，客户端使用Allocate事务。  
   客户端向服务器发送Allocate请求，服务器回复包含分配的中继传输地址的Allocate成功响应。   
   客户端可以在allocation请求中包括描述allocation类型的属性（例如，the lifetime of the allocation）。
   由于中继数据具有安全隐患，
   因此服务器要求客户端通过自身进行身份验证
  （通常使用STUN的长期凭据机制），以表明它已被授权使用服务器。
  
   一旦分配了中继传输地址，客户端必须保持allocation存活。 
   为此，客户端会定期向服务器发送Refresh请求。 
   TURN故意使用不同的方法（刷新而不是分配）进行刷新，
   以确保在allocation因某种原因消失时通知客户端。 
   刷新事务的频率由分配的生命周期决定。
   分配的默认生命周期为10分钟--选择此值足够长，
   以便刷新通常不会对客户端造成负担，
   同时使客户端意外退出的分配到期。 
   选择此值足够长，以便刷新通常不会给客户带来负担，
   当用户意外退出时，allocation的生命周期将会失效。 
    
   但是，客户端可以在Allocate请求中请求更长的生命周期，
   并可以在刷新请求中修改其请求，
   并且服务器始终指示响应中的实际生命周期。
    
   客户端必须在上一次Allocate或Refresh事务的“lifetime”秒内发出新的刷新事务。  
   一旦客户端不再希望使用allocation，它应该使用请求生存期为0的Refresh请求删除allocation。
  
   服务器和客户端都跟踪一个称为5元祖的值。
   在客户端，5元组由客户端的内网地址，端口，

   服务器外网地址,端口和客户端用于和服务器通信的传输协议(ip4或者ip6)组成。
   因为这是服务器看到的客户端地址。 

   客户端和服务器都在本地记住Allocate请求中使用的5元组。
   客户端和服务器之间的后续消息使用相同的5元组。  
   
   通过这种方式，客户端和服务器知道正在引用哪个allocation。

   如果客户希望分配第二个中继传输地址，
   它必须使用不同的5元组创建第二个分配
  （例如，通过使用不同的客户端内网地址或端口）。 

   注意：虽然本文档中使用的术语是指5元组，
   TURN服务器可以存储它喜欢的任何标识符，产生相同的结果。   
   的，实现可以使用文件描述符代替5元组来表示TCP连接。

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |-- Allocate request --------------->|             |             |
    |                                    |             |             |
    |<--------------- Allocate failure --|             |             |
    |                 (401 Unauthorized) |             |             |
    |                                    |             |             |
    |-- Allocate request --------------->|             |             |
    |                                    |             |             |
    |<---------- Allocate success resp --|             |             |
    |            (192.0.2.15:50000)      |             |             |
    //                                   //            //            //
    |                                    |             |             |
    |-- Refresh request ---------------->|             |             |
    |                                    |             |             |
    |<----------- Refresh success resp --|             |             |
    |                                    |             |             |

                                 图 2
 
  在图2中，客户端在没有凭据的情况下向服务器发送Allocate请求。
  由于服务器要求使用STUN的长期凭证机制对所有请求进行身份验证，
  因此服务器会使用401（未授权）错误代码拒绝该请求。
  然后客户端再次尝试，这次包括凭证（未示出）。

  这次，服务器接受Allocate请求并返回Allocate成功响应，
  其中包含（除其他信息外）allocation中携带的relayed transport address。
   
  一段时间以后，客户端决定刷新allocation，从而向服务器发送Refresh请求。
   服务端接受刷新，服务器回复Refresh成功响应。 

2.3.  Permissions（权限）

   为了减轻企业IT管理员对TURN可用于绕过企业防火墙安全性的担忧，TURN包含权限概念。
   TURN权限模仿符合[RFC4787]的NAT的地址过滤机制。 
   allocation可以具有零个或多个权限。 每个权限都包含IP地址和生命周期。
  
   当服务器在allocation的中继传输地址上收到UDP数据时，它首先检查权限列表。
 
   如果数据的源IP地址与权限匹配，则将应用程序数据中继到客户端，否则将静默丢弃UDP数据报。
   如果未刷新，权限将在5分钟后过期，并且无法明确删除权限。 
   选择此行为是为了匹配符合[RFC4787]中的NAT的行为。 

   客户端可以使用CreatePermission请求或ChannelBind请求安装或刷新权限。 
   使用CreatePermission请求，可以使用单个请求安装或刷新多个权限 - 
   这对于使用ICE的应用程序非常重要。
   出于安全原因，只能由可以进行身份验证的事务安装或刷新权限；
   因此，发送指示和ChannelData消息（用于向对等方发送数据）不会安装或刷新任何权限。
   请注意，权限在分allocation的上下文中， 因此，
   在一次allocation中添加或过期权限不会影响其他allocation。 
    
2.4.  Send Mechanism（发送机制）

   客户端和对等端有两种使用TURN服务器交换应用程序数据的机制。 
   第一种机制使用Send和Data方法，第二种方式使用channel。
   两种机制相同的地方是，它们都可以使用一个简单的被分配好
   的relayed transport address让客户端和众多的对等端通信。
   因此，两种方式都包括客户端告诉服务器哪个对等端应该接收数据，
   以及服务器让客户端知道哪个对等端发送数据过来。 

   发送机制使用Send和Data指令。
   Send指令用于将应用程序数据从客户端发送到服务器，
   而Data指令用于将应用程序数据从服务器发送到客户端。 

   使用发送机制时，客户端向TURN服务器发送一个发送指令，
   其中包含（a）指定对等端（外网地址）
   传输地址的XOR-PEER-ADDRESS属性和（b）保存应用程序数据的DATA属性。
   
   当TURN服务器收到发送指示时，它从DATA属性中提取应用程序数据，
   并使用分配的中继地址作为源地址，将UDP数据报发送给对等端。 
   请注意，无需指定中继的传输地址，因为Send指令使用的5元组暗示了它。 
   相反的，到达TURN服务器上的中继传输地址的UDP数据报被转换为数据指令并发送到客户端，
   对等端的外网地址包含在XOR-PEER-ADDRESS属性，而要发送的数据在DATA属性中。 
   
   由于中继的传输地址唯一地标识了allocation，
   因此服务器知道哪个客户端应该接收数据。 

   Send和Data指令无法进行身份验证，因为STUN的长期凭据机制不支持验证指示。 
   这不是一个大问题， 因为客户端到服务器的分支只是到对等端的总路径的一半。
   需要适当安全性的应用程序应加密客户端与对等方之间发送的数据。 

   由于发送指令未经过身份验证，因此攻击者可能会向服务器发送虚假发送指示，
   然后服务器会将这些指示转发给对等端。  
   为了部分缓解这种攻击，TURN要求客户端在使用发送指示向其发送数据之前向对等端安装权限。 
    
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |-- CreatePermission req (Peer A) -->|             |             |
    |<-- CreatePermission success resp --|             |             |
    |                                    |             |             |
    |--- Send ind (Peer A)-------------->|             |             |
    |                                    |=== data ===>|             |
    |                                    |             |             |
    |                                    |<== data ====|             |
    |<-------------- Data ind (Peer A) --|             |             |
    |                                    |             |             |
    |                                    |             |             |
    |--- Send ind (Peer B)-------------->|             |             |
    |                                    | dropped     |             |
    |                                    |             |             |
    |                                    |<== data ==================|
    |                            dropped |             |             |
    |                                    |             |             |

                                 图3

   在图3中，客户端已经创建了一个allocation，现在希望将数据发送给它的对等体。
   客户端首先通过向服务器发送一个CreatePermission请求来创建permission，
   该请求在XOR-PEER-ADDRESS属性中指定对等端A（服务器自反）IP地址;
   如果没有这样做，服务器将不会在客户端和服务器之间中继数据。

   然后客户端使用Send指令将数据发送到对等方A; 
   在服务器处，使用中继的传输地址作为源传输地址，
   提取应用数据并在UDP数据报文中转发到对等端A.  
   当在中继的传输地址处接收到来自对等端A的UDP数据报文时，
   将内容放入Data指令并转发到客户端。
  
   之后，客户端尝试与对等端B交换数据; 
   但是，没有为对等端B安装任何权限，
   因此服务器将丢弃来自客户端的发送指令和来自对等端的UDP数据报文。 

2.5.  Channels(通道)

   对于一些应用（例如，IP语音），
   Send指令或Data指令添加到应用数据的36字节开销可以显着增加客户端和服务器之间所需的带宽。
   为了解决这个问题，TURN为客户端和服务器提供了第二种方法，可以将数据与特定对等端相关联。 
   第二种方法使用了一种叫ChannelData 消息的数据包格式。
   ChannelData消息不使用其他TURN消息使用的STUN头，而是使用包含一种叫channel number的4字节头。
   使用中的每个通道号都绑定到特定对等端，因此可用作对等端外网地址的简写。 
   为了将信道绑定到对等端，客户端向服务器发送ChannelBind请求，
   并包括未绑定的channel number和对等端的传输地址。 
   绑定通道后，客户端可以使用ChannelData消息将数据发送指定对等端。
   类似地，服务器可以使用ChannelData消息将数据从该对等端中继到客户端。
 
   除非刷新，否则通道绑定持续10分钟 - 选择此生命周期要长于权限生命周期。

   通过发送另一个ChannelBind请求将通道重新绑定到对等放来刷新通道绑定。 
   与permissions一样（但不像allocation），没有办法明确删除通道绑定; 客户必须等待它超时。 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |-- ChannelBind req ---------------->|             |             |
    | (Peer A to 0x4001)                 |             |             |
    |                                    |             |             |
    |<---------- ChannelBind succ resp --|             |             |
    |                                    |             |             |
    |-- [0x4001] data ------------------>|             |             |
    |                                    |=== data ===>|             |
    |                                    |             |             |
    |                                    |<== data ====|             |
    |<------------------ [0x4001] data --|             |             |
    |                                    |             |             |
    |--- Send ind (Peer A)-------------->|             |             |
    |                                    |=== data ===>|             |
    |                                    |             |             |
    |                                    |<== data ====|             |
    |<------------------ [0x4001] data --|             |             |
    |                                    |             |             |

                                  图4

   图4显示了正在使用的通道机制。
   客户端已经创建了一个allocation，现在希望将一个channel绑定到Peer A.
   为此，客户端向服务器发送ChannelBind请求，指定对等端A的传输地址和通道号（0x4001）。
   之后，客户端可以将封装在ChannelData消息中的应用程序数据发送给对等方A：
   这显示为“[0x4001] data”，其中0x4001是通道编号。

   当ChannelData消息到达服务器时，服务器将数据传输到UDP数据报并将其发送到对等端A（绑定到通道号0x4001的对等端）。 
   在相反的方向上，当对等端A将UDP数据报发送到中继的传输地址时，
   该UDP数据报文到达在allocation的中继传输地址（服务器中的relayed transport address）。
    
   由于UDP数据报是从对等端A接收的，其具有分配给它的channel number，
   因此服务器在将数据发送到客户端时将数据封装到ChannelData消息中。
   一旦绑定了一个通道，客户端就可以自由地混合使用ChannelData消息和Send指令。
  
   在图中，客户端稍后决定使用Send指令而不是ChannelData消息来向对等方A发送附加数据。
     
   例如，客户端可能决定这样做，因此它可以使用DONT-FRAGMENT属性（请参阅下一节）。
   但是，一旦绑定了一个通道，服务器将始终使用ChannelData消息，如调用流程中所示。
   请注意，ChannelData消息只能用于客户端绑定了通道的对等端。
   在上面的示例中，对等端A已绑定到某个通道，但对等端B未绑定，
   因此进出对等端B的应用程序数据将使用“Send”机制。 

2.6.  Unprivileged TURN Servers（无特权服务器）

   此版本的TURN旨在使服务器可以实现为在常用操作系统下的用户空间中运行而无需特殊权限的应用程序。
   做出此设计决策是为了便于部署TURN服务器：例如，允许将TURN服务器集成到对等应用程序中，
   以便一个对等方可以向另一个对等方提供NAT穿越服务。
    
   此设计决策对TURN服务器中继的数据具有以下含义：

   o  可能无法在服务器上保留区分服务字段的值;

   o  生存时间（TTL）字段可以在服务器上重置，而不是递减;

   o  显式拥塞通知（ECN）字段可以由服务器重置;

   o  ICMP消息不由服务器中继;
    
   o  没有端到端的碎片，因为数据包在服务器上重新组装。

  未来的工作可以指定解决这些限制的备用TURN语义。

2.7.  Avoiding IP Fragmentation(避免IP分段)

   由于[Frag-Harmful]中描述的原因，应用程序（尤其是那些发送大量数据的应用程序）
   应该尽量避免将其数据包分段。
   
   使用TCP的应用程序或多或少可以忽略此问题，因为碎片避免现在是TCP的标准部分，
   但使用UDP的应用程序（以及使用此版本的TURN的任何应用程序）必须自己处理碎片避免。

   在客户端和对等端上运行的应用程序可以采用两种方法之一来避免IP碎片。

   第一种方法是避免在客户端和对等端之间交换的TURN消息/ UDP数据报中发送大量应用程序数据。  
   这是大多数VoIP（Voice-over-IP）应用程序采用的方法。
   在这种方法中，应用程序利用IP规范[RFC0791]规定最多576字节的IP数据包永远不需要分段的事实。
    
   在避免碎片的同时可以包含的应用程序数据的确切数量取决于客户端和服务器之间的TURN会话的详细信息：
   是否使用UDP，TCP或TLS传输，是否使用ChannelData消息或发送/数据指示，以及是否包括任何其他属性（例如DONT-FRAGMENT属性）。  
   另一个难以确定的因素是MTU是否因为其他原因在路径的某处减少了， 例如使用IP-in-IP隧道。
   作为指导原则，通常在单个TURN消息中（由客户端到服务器）或UDP数据报文中（由对等端到服务器端的对等端）
   发送最多500字节的应用数据，为了避免IP碎片。 
   
   为了进一步降低碎片的可能性，建议客户端在传输大量数据时使用ChannelData消息，
   因为ChannelData消息的开销小于Send和Data指令。 

   客户端和对等端可以采取的避免分段的第二种方法是使用路径MTU发现
   算法来确定可以在没有分段的情况下发送的最大应用程序数据量。
    
	遗憾的是，由于实现此版本TURN的服务器不会中继ICMP消息，
	因此[RFC1191]中定义的经典路径MTU发现算法无法发现客户端与对等端之间的传输路径的MTU。
 
   （即使它们确实中继了ICMP消息，该算法也不会始终有效，因为ICMP消息经常被组合的NAT /防火墙设备过滤掉）。

   因此，客户端和服务器需要使用不需要ICMP消息的路径MTU发现算法。 
   [RFC4821]中定义的分组化路径MTU发现算法就是这样一种算法。

   有关如何将[RFC4821]算法与TURN一起使用的详细信息仍在研究中。
   但是，作为实现此目标的一步，此版本的TURN支持DONT-FRAGMENT属性。
   当客户端在发送指令中包含此属性时，
   这将告知服务器在它发送给对等方的结果UDP数据报中设置DF位。
 
   由于某些服务器可能无法设置DF位，因此客户端还应在Allocate请求中包含此属性 - 
   任何不支持DONT-FRAGMENT属性的服务器都将通过拒绝Allocate请求来指示此情况。

2.8.  RTP Support(RTP支持)

   TURN的设想用途之一是作为希望使用RTP交换客户端和对等端的实时数据（例如，语音或视频）。 
   为了便于将TURN用于此目的，TURN包括对旧版RTP的一些特殊支持。

   旧版本的RTP [RFC3550]要求RTP流位于偶数端口号上，
   并且相关联的RTP控制协议（RTCP）流（如果存在）位于下一个最高端口上。
   为了允许客户端与仍需要它的对等端一起工作，
   TURN允许客户端请求服务器allocation具有偶数端口号的中继传输地址，
   并且可选地请求服务器为后续分配保留下一个最高端口号。
  

2.9.  Anycast Discovery of Servers（任播发现服务器）

   此版本的TURN旨在允许将来规范通过UDP进行TURN服务器的任播发现的方法。 
   具体来说，TURN服务器可以拒绝分配请求，并建议客户端尝试备用服务器。
   为了避免某些类型的攻击，客户端必须使用与备用服务器相同的凭据，
   就像使用初始服务器一样。
    
3.  Terminology(术语)

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

   Readers are expected to be familiar with [RFC5389] and the terms
   defined there.

   The following terms are used in this document:

   TURN:  The protocol spoken between a TURN client and a TURN server.
      It is an extension to the STUN protocol [RFC5389].  The protocol
      allows a client to allocate and use a relayed transport address.

   TURN client:  A STUN client that implements this specification.

   TURN server:  A STUN server that implements this specification.  It
      relays data between a TURN client and its peer(s).

   Peer:  A host with which the TURN client wishes to communicate.  The
      TURN server relays traffic between the TURN client and its
      peer(s).  The peer does not interact with the TURN server using
      the protocol defined in this document; rather, the peer receives
      data sent by the TURN server and the peer sends data towards the
      TURN server.

   Transport Address:  The combination of an IP address and a port.

   Host Transport Address:  A transport address on a client or a peer.

   Server-Reflexive Transport Address:  A transport address on the
      "public side" of a NAT.  This address is allocated by the NAT to
      correspond to a specific host transport address.

   Relayed Transport Address:  A transport address on the TURN server
      that is used for relaying packets between the client and a peer.
      A peer sends to this address on the TURN server, and the packet is
      then relayed to the client.

   TURN Server Transport Address:  A transport address on the TURN
      server that is used for sending TURN messages to the server.  This
      is the transport address that the client uses to communicate with
      the server.

   Peer Transport Address:  The transport address of the peer as seen by
      the server.  When the peer is behind a NAT, this is the peer's
      server-reflexive transport address.
	   
   Allocation:  The relayed transport address granted to a client
      through an Allocate request, along with related state, such as
      permissions and expiration timers.

   5-tuple:  The combination (client IP address and port, server IP
      address and port, and transport protocol (currently one of UDP,
      TCP, or TLS)) used to communicate between the client and the
      server.  The 5-tuple uniquely identifies this communication
      stream.  The 5-tuple also uniquely identifies the Allocation on
      the server.

   Channel:  A channel number and associated peer transport address.
      Once a channel number is bound to a peer's transport address, the
      client and server can use the more bandwidth-efficient ChannelData
      message to exchange data.

   Permission:  The IP address and transport protocol (but not the port)
      of a peer that is permitted to send traffic to the TURN server and
      have that traffic relayed to the TURN client.  The TURN server
      will only forward traffic to its client from peers that match an
      existing permission.

   Realm:  A string used to describe the server or a context within the
      server.  The realm tells the client which username and password
      combination to use to authenticate requests.

   Nonce:  A string chosen at random by the server and included in the
      message-digest.  To prevent reply attacks, the server should
      change the nonce regularly.

4.  General Behavior(一般行为)

   本节包含适用于所有TURN消息的常规TURN处理规则。 
   TURN是STUN的扩展。 除ChannelData消息外，所有TURN消息都是STUN格式的消息。 
   [RFC5389]中描述的所有基本处理规则适用于STUN格式的消息。
   这意味着本文档中的所有消息形成和消息处理描述都隐含地以[RFC5389]的规则为前缀。

   [RFC5389]指定了一种称为长期凭证机制的认证机制。 
   TURN服务器和客户端必须实现这种机制。 
   服务器必须要求使用此机制对来自客户端的所有请求进行身份验证，
   或者使用同样强大或更强的客户端身份验证机制。
    
   请注意，长期凭证机制仅适用于请求，不能用于验证指令;
   因此，TURN中的指令从未被认证。
   
   如果服务器要求进行身份验证请求，
   则服务器的管理员必须选择一个realm值，
   该值将唯一标识客户端必须使用的用户名和密码组合，
   即使客户端在不同的管理下使用多个服务器也是如此。
   
   服务器的管理员可以选择为每个客户端分配唯一的用户名，
   或者可以选择将同一用户名分配给多个客户端（例如，分配给同一部门或公司的所有客户端）。
   
   对于每个分配，服务器应该在[RFC4086]中的随机性建议之后首次尝试
   分配时生成新的随机nonce，并且应该在allocation的生命周期内
   每小时至少使一次nonce到期。 

   初始分配后的所有请求必须使用与用于创建分配的
   用户名相同的用户名，以防止攻击者劫持客户端的allocation。 
   
   具体来说，如果服务器需要使用长期凭证机制，
   并且非Allocate请求在此机制下通过身份验证，
   并且5-tuple标识现有分配，但请求不使用相同的用户名 
   用于创建分配，然后客户端会收到拒绝请求441（错误的凭据）错误。

   当TURN消息从客户端到达服务器时，服务器使用消息中的5元组来标识关联的分配。
   对于所有TURN消息（包括ChannelData）除了分配请求之外，如果5元组没有识别现有allocation，
   则必须拒绝该消息并发出437allocation不匹配错误（如果是请求）
   或者忽略（如果 它是一个指令或ChannelData消息）。 

   收到除Allocate以外的请求的437错误响应的客户端必须假定分配不再存在。

   [RFC5389]定义了许多属性，包括SOFTWARE和FINGERPRINT属性。
   客户端应该在所有Allocate和Refresh请求中包含SOFTWARE属性，
   并且可以将其包含在任何其他请求或指示中。 
 
   客户端和服务器可以在本文档中定义的任何STUN格式的消息中包含FINGERPRINT属性。
   TURN不使用[RFC5389]中描述的向后兼容机制。
    
   如本说明书中所定义的，TURN仅支持IPv4。 客户端的IP地址，
   服务器的IP地址以及出现在中继传输地址中的所有IP地址必须是IPv4地址。

   默认情况下，TURN在与STUN相同的端口上运行：
   3478用于通过UDP和TCP进行TURN，以及5349用于TURN over TLS。
   但是，TURN有自己的一组服务记录（SRV）名称：UDP转换TCP， TLS转换。
   可以使用第6节中描述的SRV过程或ALTERNATE-SERVER过程在不同的端口上运行TURN。

   为了确保互操作性，TURN服务器必须支持在客户端和服务器之间使用UDP传输，
   并且应该支持使用TCP和TLS传输。

   在客户端和服务器之间使用UDP传输时，如果请求在某个超时时间内没有收到响应，则客户端将重新发送请求。
   因此，服务器可以接收具有相同5元组和相同事务id的两个（或更多）请求。  
   STUN要求服务器识别这种情况并将请求视为幂等（请参阅[RFC5389]）。
   一些实现可以通过记住所有接收的请求和相应的响应40秒来选择满足该要求。

   其他实现可以选择重新处理请求并安排这样的重新处理返回基本相同的响应。  
   为了帮助选择后一种方法的实现者（所谓的“无状态堆栈方法”），
   本规范包括一些关于如何完成此操作的实现说明。 
   实现可以自由选择任一种方法，也可以选择其他方法来提供相同的结果。

   当在客户端和服务器之间使用TCP传输时，位错误可能会导致TURN数据包中的长度字段损坏，
   从而导致接收器与传入的TURN消息流失去同步。
   通过TCP传输检测长序列无效TURN消息的客户端或服务器应该关闭相应的TCP连接，
   以帮助另一端更快地检测到这种情况。

   为了减轻具有有效用户名和密码的客户端对服务器的有意或无意的拒绝服务攻击，
   建议服务器对给定用户名一次激活的分配数量以及这些分配可以使用的带宽量施加限制。 
   服务器应拒绝超过允许的分配数限制的新分配，
   并回复486错误（超出分配配额）（参见第6.2节），
   并且应丢弃超出带宽配额的应用程序数据流量。
    
5.  Allocations

   所有TURN操作都围绕Allocation，所有TURN消息都与Allocation相关联。 
   Allocation在概念上由以下状态数据组成：

   o  服务端 relayed transport address;

   o  5元组:(客户端的IP地址，客户端的端口，服务器IP地址，服务器端口，传输协议）;

   o 认证信息;

   o  到期时间;

   o 权限列表;

   o 通道到对等端绑定的列表。

   中继的传输地址是服务器为与对等体通信而分配的传输地址，而5元组则描述了客户端与服务器之间的通信路径。
   
   在客户端上，5元组使用客户端的主机传输地址; 在服务器上，5元组使用客户端的外网地址。

   中继的传输地址和5元组在所有分配中必须是唯一的，因此任何一个都可以用于唯一地标识allocation。

   认证信息（例如，用户名，密码，领域和现时）用于验证后续请求和计算响应的消息完整性。
   
   username，realm和nonce是最初在创建Allocation时经过身份验证的Allocate请求中使用的值，
   尽管服务器可以使用438（Stale Nonce）回复在分配的生命周期内更改nonce值。

   请注意，处于安全原因。它可能是一个值，
   是根据username，realm，password算出来的MD5值。（参见[RFC5389]） 

   到期时间是allocation到期之前的剩余时间。 
   每个Allocate或Refresh事务都设置此计时器，然后向下计数到0。
   默认情况下，每个Allocate或Refresh事务会将此计时器重置为600秒
   （10分钟）的默认生存期值，
   但客户端可以在Allocate和Refresh请求中请求不同的值。
   只能使用Refresh请求刷新分配; 向对等端发送数据不会刷新分配。   
   当分配到期时，可以释放与分配相关联的状态数据。
   权限列表在第8节中描述，通道列表在第11节中描述。 

6.  Creating an Allocation

   使用Allocate事务创建服务器上的Allocation。

6.1.  Sending an Allocate Request

   客户端按如下方式形成分配请求。
   客户端首先选择一个内网地址。
   建议客户端选择当前未使用的传输地址，
   通常是允许底层操作系统为新套接字选择当前未使用的端口。
   然后，客户端选择要在客户端和服务器之间使用的传输协议。 
   传输协议必须是UDP，TCP或TLS-over-TCP之一。
   由于此规范仅允许服务器和对等体之间的UDP，因此建议客户端选择UDP，
   除非它有理由使用不同的传输。
   选择不同运输的一个原因是客户认为，
   无论是通过配置还是通过实验，它都无法使用UDP联系任何TURN服务器。
   有关更多讨论，请参见第2.1节。

   客户端还会选择一个服务器地址，该地址应该按如下方式完成。
   客户端（可能通过配置）接收TURN服务器的域名。
   然后，客户端使用[RFC5389]中描述的DNS过程，但使用SRV服务名称“turn”
   （或“TURN over TLS”）而不是“stun”（或“stuns”）。
   例如，要在example.com域中查找服务器，
   客户端将执行“_turn._udp.example.com”，
   “_ turn._tcp.example.com”和“_turns._tcp.example.com”的查找。 
   客户端希望分别使用UDP，TCP或TLS-over-TCP与服务器通信。

   客户端必须在请求中包含REQUESTED-TRANSPORT属性。 
   此属性指定服务器和对等方之间的传输协议
   （请注意，这不是出现在5元组中的传输协议）。
   在本说明书中，REQUESTED- TRANSPORT类型始终为UDP。 
   包含此属性以允许将来的扩展指定其他协议。

   如果客户端希望服务器将分配的到期时间字段初始化为除默认生存期之外的某个值，
   则它可以包括指定其期望值的LIFETIME属性。
   这只是一个请求，服务器可能会选择使用不同的值。 
   请注意，服务器将忽略将字段初始化为小于默认值的请求。

   如果客户端希望稍后在此分配的一个或多个发送指示中使用DONT-FRAGMENT属性，
   则客户端应该在Allocate请求中包含DONT-FRAGMENT属性。
   这允许客户端测试服务器是否支持此属性。

   如果客户端要求中继传输地址的端口号为偶数，则客户端包括EVEN-PORT属性。
   如果未包含此属性，则端口可以是偶数或奇数。
   通过将EVEN-PORT属性中的R位设置为1，
   客户端可以请求服务器为后续分配保留下一个最高端口号（在同一IP地址上）。 
   如果R位为0，则不会发出此类请求。

   客户端还可以在请求中包含RESERVATION-TOKEN属性，
   以要求服务器使用先前保留的端口进行分配。
   如果包含RESERVATION-TOKEN属性，则客户端必须省略EVEN-PORT属性。 
   构建完成后，客户端会在5元组上发送Allocate请求。

6.2.  Receiving an Allocate Request

   当服务器收到Allocate请求时，它会执行以下检查：

   1. 服务器必须要求对请求进行身份验证。 
      此身份验证必须使用[RFC5389]的长期凭据机制来完成，
      除非客户端和服务器同意通过本文档范围之外的某些过程使用其他机制。

   2. 服务器检查现有分配当前是否正在使用5元组。 
      如果是，则服务器拒绝具有437（分配不匹配）错误的请求。

   3. 服务器检查请求是否包含REQUESTED-TRANSPORT属性。
	  如果未包含REQUESTED-TRANSPORT属性或格式错误，
	  则服务器会拒绝400（错误请求）错误的请求。 
	  否则，如果包含该属性但指定了UDP之外的协议，
	  则服务器会拒绝具有442（不支持的传输协议）错误的请求。
	    
   4. 该请求可能包含DONT-FRAGMENT属性。 
      如果是，但服务器不支持发送DF位设置为1的UDP数据报（参见第12节），
      则服务器将Allocate请求中的DONT-FRAGMENT属性视为未知的理解所需属性。

   5. 服务器检查请求是否包含RESERVATION-TOKEN属性。
      如果是，并且请求还包含EVEN-PORT属性，
	  则服务器拒绝具有400（错误请求）错误的请求。
	  否则，它检查token是否有效
	  （即，token在范围内并且尚未到期并且相应的中继传输地址仍然可用）。 
	   如果token因某种原因无效，则服务器会拒绝508（容量不足）错误的请求。

   6. 服务器检查请求是否包含EVEN-PORT属性。 
      如果是，则服务器检查它是否可以满足请求
     （即，可以分配如下所述的中继传输地址）。
	  如果服务器无法满足请求，则服务器会拒绝具有508（容量不足）错误的请求。

   7.  在任何时候，如果服务器感觉客户端试图超过某些本地定义的分配配额，
       则可以选择拒绝具有486（已达到分配的配额）错误的请求。
	  
	  服务器可以任意方式自由定义此allocation配额，
      但是应该根据用于验证请求的用户名来定义它，  
      而不是客户的运输地址。 

   8.  此外，如果希望将客户端重定向到其他服务器，
       服务器可以选择拒绝300（尝试替换）错误的请求。
	   此错误代码和属性的使用遵循[RFC5389]中的规范。

  如果所有检查都通过，则服务器创建allocation。 
  5元组设置为Allocate请求的5元组，
  而权限列表和通道列表最初为空。

   服务器为allocation选择中继传输地址，如下所示： 

   o  如果请求包含RESERVATION-TOKEN，
      则服务器使用先前保留的与包含的令牌相对应的传输地址（如果它仍然可用）。

	  请注意，预留是服务器范围的预留，并不特定于特定的allocation，
	  因为包含RESERVATION-TOKEN的Allocate请求使用与
	  进行预留的Allocate请求不同的5元组。 
	  包含RESERVATION-TOKEN属性的Allocate请求的5元组可以是任何允许的5元组;
	  它可以使用不同的客户端IP地址和端口，不同的传输协议，
	  甚至不同的服务器IP地址和端口（当然，
	  提供服务器IP地址和端口是服务器正在侦听TURN请求的服务器IP地址和端口）。

   o  如果请求包含R位设置为0的EVEN-PORT属性，
      则服务器将分配带有偶数端口号的中继传输地址。

   o  如果请求包含R位设置为1的EVEN-PORT属性，
      则服务器在同一IP地址上查找一对端口号N和N + 1，其中N为偶数。
	  端口N用于当前分配，而具有端口N + 1的中继传输
	  地址被分配一个令牌并保留用于将来的分配。 
      服务器必须保持此预留至少30秒，并且可以选
	  择保持更长时间（例如，直到具有端口N的分配到期）。
	  然后，服务器将令牌包含在成功响应中的RESERVATION-TOKEN属性中。

   o  否则，服务器分配任何可用的中继传输地址。

   在所有情况下，服务器应该只分配范围49152-65535
  （动态和/或专用端口范围[端口号]）的端口，
   除非TURN服务器应用程序知道，
   通过这里未指定的某种方式，
   在同一台主机的TURN服务器应用程序上运行的其他
   应用程序不会受到此范围外的端口分配会受到影响。

   通常可以通过在专用机器上运行TURN服务器应用程序和/或通
   过安排机器上的任何其他应用程序在TURN服务器应用程序
   启动之前分配端口来满足此条件。 
  

   注意：IETF目前正在研究随机端口分配的主题，
   以避免某些类型的攻击（参见[TSVWG-PORT]）。
   强烈建议TURN实现者及时了解该主题，
   并在适当的情况下实现随机端口分配算法。
	
   这尤其适用于选择从底层操作系统预分配多个端口然后
   将它们分配给分配的服务器; 例如，
   服务器可以选择此技术来实现EVEN-PORT属性。
 
	   
   服务器确定到期时间字段的初始值，如下所示。
   如果请求包含LIFETIME属性，则服务器计算客户端建
   议生存期的最小值和服务器的最大允许生存期。 
   如果此计算值大于默认生存期，则服务器使用
   计算的生存期作为到期时间字段的初始值。
   否则，服务器使用默认生存期。
   建议服务器使用不超过3600秒（1小时）
   的最大允许生命周期值。
   服务端分配配合或向客户端所要一个小小的最大lifetime，
   可以让快的删除无用的allocation。
   另请注意，每次成功刷新请求都会重新计算到期时间，
   因此此处计算的值仅适用于第一次刷新。 
   
   创建分配后，服务器将回复成功响应。 成功响应包含：

   o  包含中继传输地址的XOR-RELAYED-ADDRESS属性。

   o  LIFETIME属性，包含到期时间计时器的当前值。

   o  RESERVATION-TOKEN属性（如果保留了第二个中继传输地址）。

   o  包含客户端IP地址和端口的XOR-MAPPED-ADDRESS属性（来自5元组）。

      注意：响应中包含XOR-MAPPED-ADDRESS属性，以方便客户端。
	  TURN本身不使用此值，但运行ICE的客户端通常需要此值，
	  因此可以避免与某些STUN服务器进行额外的Binding事务来知道它。 

  响应（成功或错误）将在5元组上发送回客户端。

      注意：当通过UDP发送分配请求时，
	  [RFC5389]的第7.3.1节要求服务器处理请求的可能重传，
	  以便重新传输不会导致创建多个分配。 
	  实现可以使用如下所谓的“无状态堆栈方法”来实现这一点。
  
	  To detect retransmissions when the original request was
      successful in creating an allocation, the server can store the 
      transaction id that created the request with the allocation data
      and compare it with incoming Allocate requests on the same
      5-tuple. 
	  
	  一旦检测到这样的请求，服务器就可以停止解析请求并立即生成成功响应。
	  
      构建此响应时，可以从分配状态数据中的time-to-expiry字段获取LIFETIME属性的值，
	  即使此值可能与最初返回的LIFETIME值略有不同。

	  此外，服务器可能需要存储原始响应中返回的任何预留令牌的指令，
	  以便可以在任何重新传输的响应中返回。

      对于原始请求在创建分配时不成功的情况，服务器可以选择不做任何特殊操作。
	  但请注意，在极少数情况下服务器拒绝原始请求但接受重新传输的请求
	  （因为条件在短暂的中间时间段内已发生变化）。 
	  
	  如果客户端收到第一个失败响应，它将忽略第二个（成功）响应并认为未创建分配。
	  在此问题中创建的分配最终会超时，因为客户端不会刷新它。
      此外，如果客户端稍后使用相同的5元组但不同的事务ID重试，它将收到437
	  （分配不匹配），这将导致它使用不同的5元组重试。

      服务器可以使用较小的最大寿命值来以这种方式最小化“孤立”分配的寿命。

6.3.  Receiving an Allocate Success Response（接收分配成功响应）

   如果客户端收到分配成功响应，则它必须检查映射地址和中继传
   输地址是否在客户端理解并准备处理的地址族中。 
   该规范仅涵盖这两个地址是IPv4地址的情况。
   如果这两个地址不在客户端准备处理的地址族中，那么客户端必须删除分配（第7节），
   并且不得尝试在该服务器上创建另一个分配，直到它认为不匹配已被修复。

     IETF目前正在考虑在IPv4和IPv6之间转换的机制，
	 这可能导致客户端通过IPv6发起分配请求，
	 但请求将通过IPv4到达服务器，反之亦然。

   否则，客户端会创建自己的分配数据结构副本，以跟踪服务器上发生的情况。 
   特别是，客户端需要记住从服务器收到的实际生命周期，
   而不是请求中发送给服务器的值。
    
   客户端还必须记住用于请求的5元组以及用于验证请求的用户名和密码，
   以确保它将它们重用于后续消息。
   客户端还需要跟踪它在服务器上建立的通道和权限。

   客户端可能希望将中继的传输地址发送给对等体（使用此处未指定的某种方法），
   以便对等体可以与之通信。 
   客户端还可能希望在其ICE处理中使用它在XOR-MAPPED-ADDRESS
   属性中接收的外网地址。

6.4.  Receiving an Allocate Error Response

   If the client receives an Allocate error response, then the
   processing depends on the actual error code returned:

   o  (Request timed out): There is either a problem with the server, or
      a problem reaching the server with the chosen transport.  The
      client considers the current transaction as having failed but MAY
      choose to retry the Allocate request using a different transport
      (e.g., TCP instead of UDP).

   o  300 (Try Alternate): The server would like the client to use the
      server specified in the ALTERNATE-SERVER attribute instead.  The
      client considers the current transaction as having failed, but
      SHOULD try the Allocate request with the alternate server before
      trying any other servers (e.g., other servers discovered using the
      SRV procedures).  When trying the Allocate request with the
      alternate server, the client follows the ALTERNATE-SERVER
      procedures specified in [RFC5389].

   o  400 (Bad Request): The server believes the client's request is
      malformed for some reason.  The client considers the current
      transaction as having failed.  The client MAY notify the user or
      operator and SHOULD NOT retry the request with this server until
      it believes the problem has been fixed.

   o  401 (Unauthorized): If the client has followed the procedures of
      the long-term credential mechanism and still gets this error, then
      the server is not accepting the client's credentials.  In this
      case, the client considers the current transaction as having
      failed and SHOULD notify the user or operator.  The client SHOULD
      NOT send any further requests to this server until it believes the
      problem has been fixed.
	   
   o  403 (Forbidden): The request is valid, but the server is refusing
      to perform it, likely due to administrative restrictions.  The
      client considers the current transaction as having failed.  The
      client MAY notify the user or operator and SHOULD NOT retry the
      same request with this server until it believes the problem has
      been fixed.

   o  420 (Unknown Attribute): If the client included a DONT-FRAGMENT
      attribute in the request and the server rejected the request with
      a 420 error code and listed the DONT-FRAGMENT attribute in the
      UNKNOWN-ATTRIBUTES attribute in the error response, then the
      client now knows that the server does not support the DONT-
      FRAGMENT attribute.  The client considers the current transaction
      as having failed but MAY choose to retry the Allocate request
      without the DONT-FRAGMENT attribute.

   o  437 (Allocation Mismatch): This indicates that the client has
      picked a 5-tuple that the server sees as already in use.  One way
      this could happen is if an intervening NAT assigned a mapped
      transport address that was used by another client that recently
      crashed.  The client considers the current transaction as having
      failed.  The client SHOULD pick another client transport address
      and retry the Allocate request (using a different transaction id).
      The client SHOULD try three different client transport addresses
      before giving up on this server.  Once the client gives up on the
      server, it SHOULD NOT try to create another allocation on the
      server for 2 minutes.

   o  438 (Stale Nonce): See the procedures for the long-term credential
      mechanism [RFC5389].

   o  441 (Wrong Credentials): The client should not receive this error
      in response to a Allocate request.  The client MAY notify the user
      or operator and SHOULD NOT retry the same request with this server
      until it believes the problem has been fixed.

   o  442 (Unsupported Transport Address): The client should not receive
      this error in response to a request for a UDP allocation.  The
      client MAY notify the user or operator and SHOULD NOT reattempt
      the request with this server until it believes the problem has
      been fixed.

   o  486 (Allocation Quota Reached): The server is currently unable to
      create any more allocations with this username.  The client
      considers the current transaction as having failed.  The client
      SHOULD wait at least 1 minute before trying to create any more
      allocations on the server.
	   
   o  508 (Insufficient Capacity): The server has no more relayed
      transport addresses available, or has none with the requested
      properties, or the one that was reserved is no longer available.
      The client considers the current operation as having failed.  If
      the client is using either the EVEN-PORT or the RESERVATION-TOKEN
      attribute, then the client MAY choose to remove or modify this
      attribute and try again immediately.  Otherwise, the client SHOULD
      wait at least 1 minute before trying to create any more
      allocations on this server.

   An unknown error response MUST be handled as described in [RFC5389].

7.  Refreshing an Allocation

   A Refresh transaction can be used to either (a) refresh an existing
   allocation and update its time-to-expiry or (b) delete an existing
   allocation.

   If a client wishes to continue using an allocation, then the client
   MUST refresh it before it expires.  It is suggested that the client
   refresh the allocation roughly 1 minute before it expires.  If a
   client no longer wishes to use an allocation, then it SHOULD
   explicitly delete the allocation.  A client MAY refresh an allocation
   at any time for other reasons.

7.1.  Sending a Refresh Request

   如果客户端希望立即删除现有分配，则它包含值为0的LIFETIME属性。
   所有其他形式的请求都会刷新分配。

   刷新事务更新allocation的到期时间。
   如果客户端希望服务器将到期时间设置为默认生存期以外的其他时间，
   则它包含具有所请求值的LIFETIME属性。
   然后，服务器以与分配事务相同的方式计算新的到期时间值，
   但请求的生存期为0会导致服务器立即删除分配。

7.2.  Receiving a Refresh Request

   当服务器收到刷新请求时，它将按照第4节以及此处提到的特定规则进行处理。

   服务器计算称为“期望生命周期”的值，如下所示：
   如果请求包含LIFETIME属性且属性值为0，则“期望生命周期”为0。 
   否则，如果请求包含LIFETIME属性，则服务器计算客户端请求生
   存期的最小值和服务器的最大允许生存期。
   如果此计算值比默认生存期更好，则“期望生命周期”是计算值。
   否则，“期望的生命周期”是默认生命周期。

   后续处理取决于“期望的生命周期”值：

   o  如果“期望的生命周期”为0，则请求成功并删除allocation。

   o  如果“期望的寿命”不为零，则请求成功，
      并且分配的到期时间设置为“期望的寿命”。

   如果请求成功，则服务器发送成功响应 包含：

   o  LIFETIME属性，包含到期时间计时器的当前值。

      注意：服务器不需要做任何特殊的事情来使用“无状态堆栈方法”
	  通过UDP实现刷新请求的幂等性。
	  具有非零“desired lifetime”的重新传输刷新请求将简单地刷新分配。
 
	  如果已经删除了分配，则具有零“期望生存期”的重新传输的刷新请求将导致437
	  （分配不匹配）响应，但客户端将其视为等同于成功响应（参见下文）。

7.3.  Receiving a Refresh Response

   如果客户端收到对其刷新请求的成功响应且生命周期为非零，
   则它会更新其分配数据结构的副本，其中包含响应中包含的到期时间值。

   如果客户端收到对删除分配的请求的437（Allocation Mismatch）错误响应，
   则分配不再存在，并且应该认为其请求已经有效成功。

8.  Permissions

   对于每个分配，服务器保留零个或多个权限的列表。
   每个权限都包含一个IP地址和一个相关的到期时间。 存在权限时，
   允许在权限中使用IP地址的所有对等方将数据发送到客户端。
   
   到期时间是许可到期之前的秒数。
   在分配的上下文中，权限由其关联的IP地址唯一标识。

   通过发送CreatePermission请求或ChannelBind请求，客户端可以使服务器安装或
   刷新给定IP地址的权限。 这导致两件事之一发生：

   o  如果不存在该IP地址的权限，
      然后使用给定的IP地址创建一个权限，并且到期时间等于Permission Lifetime。
   
   o  如果已存在该IP地址的权限，则该权限的到期时间将重置为Permission Lifetime。

   权限生命周期必须为300秒（= 5分钟）。

   每个权限的到期时间每秒减少一次，直到达到0; 此时，权限到期并被删除。

   CreatePermission和ChannelBind请求可以在权限上自由混合。
   最初可以使用CreatePermission请求安装和/或刷新给定的权限，
   然后使用ChannelBind请求刷新，反之亦然。

   当UDP数据报文到达用于分配的中继传输地址时，服务器从IP报头中提取源IP地址。
   然后，服务器将此地址与分配权限列表中与每个权限关联的IP地址进行比较。
   如果未找到匹配项，则不允许中继，服务器将以静默方式丢弃UDP数据报。
   如果找到完全匹配，则认为权限检查已成功，
   服务器继续处理其他地方指定的UDP数据报文（第10.3节）。
   请注意，仅比较地址并且不考虑端口号。

   一个分配的权限与不同分配的权限完全无关。 
   如果分配到期，则其所有权限都将随之失效。

      注意：虽然TURN权限在5分钟后过期，
	  但在发布时部署的许多NAT会以相当快的速度使其UDP绑定到期。
	  因此，使用TURN的应用程序可能希望以更快的速率发送某种保活消息。 
	  使用ICE的应用程序应遵循ICE [RFC5245]的保持活动指南，
	  建议不使用ICE的应用程序执行类似的操作。
	   
9.  CreatePermission

   TURN支持客户端在服务器上安装或刷新权限的两种方式。 
   本节介绍一种方法：CreatePermission请求。

   CreatePermission请求可以与第10节中的Send机制或第11节中的Channel机制一起使用。

9.1.  Forming a CreatePermission Request

   希望安装或刷新一个或多个权限的客户端可以向服务器发送CreatePermission请求。

   在形成CreatePermission请求时，客户端必须至少包含一个XOR-PEER-ADDRESS属性，
   并且可以包含多个这样的属性。 
   每个XOR-PEER-ADDRESS属性的IP地址部分包含应为其安装或刷新权限的IP地址。
   每个XOR-PEER-ADDRESS属性的端口部分将被忽略，可以是任意值。
   各种XOR-PEER-ADDRESS属性可以按任何顺序出现。

9.2.  Receiving a CreatePermission Request

   当服务器收到CreatePermission请求时，它将按照第4节以及此处提到的特定规则进行处理。

   检查消息的有效性。 CreatePermission请求必须至少包含一个XOR-PEER-ADDRESS属性，并且可以包含多个这样的属性。
   如果不存在此类属性，则返回400（错误请求）错误。 
   如果请求有效，但由于某些容量限制或类似服务器无法满足请求，则返回508（容量不足）错误。

   服务器可以对XOR-PEER-ADDRESS属性中允许的IP地址施加限制 - 如果不允许值，
   则服务器拒绝具有403（禁止）错误的请求。

   如果消息有效且服务器能够执行请求，则服务器将安装或刷新每个
   XOR-PEER-ADDRESS属性中包含的IP地址的权限，如第8节所述。
   每个属性的端口部分都被忽略，可以是任意值。

   然后，服务器以CreatePermission成功响应进行响应。 成功响应中没有强制属性。
    
      注意：服务器不需要做任何特殊的事情来使用“无状态堆栈方法”
	  通过UDP实现CreatePermission请求的幂等性。
	  重新传输的CreatePermission请求将只刷新权限。

9.3.  Receiving a CreatePermission Response

   如果客户端收到有效的CreatePermission成功响应，
   则客户端将更新其数据结构以指示已安装或刷新权限。

10.  Send and Data Methods

   TURN支持两种从对等方发送和接收数据的机制。 
   本节描述了Send和Data机制的使用，而第11节描述了Channel机制的使用。

10.1.  Forming a Send Indication

   客户端可以使用发送指令将数据传递到服务器以便中继到对等方。 
   即使已经信道绑定到该对等端，客户端也可以使用Send指令给它。
   但是，客户端必须确保为发送Send指令的对等体的IP地址安装了权限; 
   这可以防止第三方使用TURN服务器将数据发送到任意目的地。

   当形成Send令示时，客户端必须包括XOR-PEER-ADDRESS属性和DATA属性。  
   XOR-PEER-ADDRESS属性包含要将数据发送到的对等方的传输地址，
   DATA属性包含要发送给对等方的实际应用程序数据。

   如果客户端希望服务器在发送给对等方的UDP数据报上设置DF位，
   则客户端可以在发送指示中包含DONT-FRAGMENT属性。

10.2.  Receiving a Send Indication

   当服务器收到发送指令时，它按照第4节以及此处提到的特定规则进行处理。 
   首先检查消息的有效性。 发送指令必须包含XOR-PEER-ADDRESS属性和DATA属性。
   如果其中一个属性丢失或无效，则丢弃该消息。 
   请注意，允许DATA属性包含零字节数据。
    
   发送指令还可以包含DONT-FRAGMENT属性。 
   如果服务器在此属性存在时无法在传出UDP数据报上设置DF位，
   则服务器就像DONT-FRAGMENT属性是未知的理解所需属性（因此丢弃发送指示）。

   服务器还检查是否为XOR-PEER-ADDRESS属性中包含的IP地址安装了权限。 
   如果不存在此类权限，则会丢弃该消息。 
   请注意，发送指令永远不会导致服务器刷新权限。

   服务器可以对XOR-PEER-ADDRESS属性中允许的IP地址和端口值施加限制 - 如果不允许值，
   服务器将静默地丢弃发送指示。

   如果一切正常，则服务器形成UDP数据报，如下所示：

   o  源传输地址是allocation的中继传输地址，其中allocation由发送指示到达的5元组确定;
    
   o  目标传输地址取自XOR-PEER-ADDRESS属性;

   o  UDP标头后面的数据是DATA属性的值字段的内容。

   第12节描述了DONT-FRAGMENT属性（如果存在）的处理。 
   然后将生成的UDP数据报发送给对等体。

10.3.  Receiving a UDP Datagram

   当服务器在当前分配的中继传输地址处接收UDP数据报时，
   服务器查找与中继传输地址相关联的allocation。 

   如果允许中继，则服务器检查是否存在绑定到发送UDP数据报
   的对等体的信道（参见第11节）。
   如果绑定了一个通道，则处理按第11.7节所述进行。

   如果允许中继但没有信道绑定到对等端，
   则服务器形成并发送数据指令。 
   数据指令必须包含XOR-PEER-ADDRESS和DATA属性。

   DATA属性设置为数据报中“data octets”字段的值，
   XOR-PEER-ADDRESS属性设置为接收到的UDP数据报的源传输地址。 
   然后，在与allocation相关联的5元组上发送数据指示。 

10.4.  Receiving a Data Indication

   当客户端收到Data指令时，
   它会检查Data指示是否同时包含XOR-PEER-ADDRESS和DATA属性，
   如果没有，则丢弃该指令。
   
   客户端还应该检查XOR-PEER-ADDRESS属性值是否包含客户
   端认为存在活动权限的IP地址，否则丢弃数据指示。
   请注意，允许DATA属性包含零字节数据。

      注意：后一项检查可以保护客户端免受攻击者的攻击，
	  该攻击者以某种方式欺骗服务器以安装客户端不需要的权限。

   如果数据指示通过上述检查，则客户端将DATA属性内的
   数据八位字节传递给应用程序，并指示它们是从对等方接收的，
   其对等方的传输地址由XOR-PEER-ADDRESS属性给出。

11.  Channels

   通道为客户端和服务器提供了一种使用ChannelData消息发送应用程序数据的方法，
   ChannelData消息的开销小于发送和数据指示。

   ChannelData消息（参见11.4节）以一个带有通道号的双字节字段开头。 
   该字段的值分配如下：

      0x0000到0x3FFF：这些值永远不能用于通道编号。

      0x4000到0x7FFF：这些值是允许的通道编号（16,383个可能的值）。

      0x8000到0xFFFF：这些值保留供将来使用。

   由于这种划分，可以通过检查消息的前两位来区分ChannelData消息与STUN格式的消息
   （例如，分配请求，发送指示等）：

      0b00：STUN格式的消息（因为STUN格式的消息的前两位始终为零）。
	   
      0b01：ChannelData消息（因为通道号是ChannelData消息中的第一个字段，
	  通道号落在0x4000  -  0x7FFF范围内）。

      0b10: 保留

      0b11: 保留

   可以在将来使用保留值来扩展信道号的范围。
   因此，实现绝不能假设TURN消息始终以0位开始。

   通道绑定始终由客户端启动。 客户端可以在分配的生命周期内的任何时间将信道绑定到对等方。

   客户端可以在与其交换数据之前，或者在与其交换数据
   （使用发送和数据指示）一段时间之后将信道绑定到对等体，
   或者可以选择永远不要将频道绑定到它。
   
   客户端还可以将信道绑定到某些对等体，而不将信道绑定到其他对等体。

   通道绑定特定于allocation，因此在一个allocation的通道绑定中使用
   的通道号和对等端地址也可以在其他的allocation中的使用。
   如果分配到期，则其所有通道绑定都将随之失效。 

    channel binding 包括:

   o  频道号码;

   o  对等端传输地址

   o  到期时间计时器。

   在allocation的上下文中，通道绑定由通道号或对等方的传输地址唯一标识。 
   因此，相同的信道不能绑定到两个不同的传输地址，
   也不能将相同的传输地址绑定到两个不同的信道。

   除非刷新，否则通道绑定将持续10分钟。 刷新绑定
   （通过服务器接收将频道重新绑定到同一对等体的ChannelBind请求）
   将到期时间计时器重置为10分钟。

   当通道绑定到期时，通道将变为未绑定。
   一旦未绑定，可以将信道号绑定到不同的传输地址，
   并且可以将传输地址绑定到不同的信道号。

   为了防止竞争条件，客户端必须在通道绑定到。
   期后等待5分钟才能尝试将通道号绑定到不同的
   传输地址或将传输地址绑定到不同的通道号。

   将通道绑定到对等方时，客户端应该准备好在它发送
   ChannelBind请求后立即从服务器接收通道上的ChannelData消息。 

   通过UDP，客户端可能在收到ChannelBind成功
   响应之前从服务器接收ChannelData消息。

   在另一个方向，客户端可能选择在接收ChannelBind
   成功响应之前发送ChannelData消息。

   但是，如果由于某种原因ChannelBind请求未成功
   （例如，如果请求是通过UDP发送的，或者服务器无法满足请求，
    则丢失数据包），这样做会冒着服务器丢弃ChannelData消息的风险。
   
   希望安全的客户端应排队数据或使用发送指示直到确认通道绑定。

11.1.  Sending a ChannelBind Request

   使用ChannelBind事务创建或刷新通道绑定。
   ChannelBind事务还会创建或刷新对等体的权限（参见第8节）。

   要启动ChannelBind事务，客户端会形成ChannelBind请求。
   要绑定的通道在CHANNEL-NUMBER属性中指定，
   并且对等方的传输地址在XOR-PEER-ADDRESS属性中指定。
 
   第11.2节描述了对这些属性的限制。
   将通道重新绑定到已绑定的相同传输地址，
   提供了一种刷新通道绑定和相应权限的方法，而无需将数据发送到对等方。
   但请注意，权限需要比频道更频繁地刷新。

11.2.  Receiving a ChannelBind Request

   当服务器收到ChannelBind请求时，它将按照第4节以及此处提到的特定规则进行处理。

   服务器检查以下内容：

   o  该请求包含CHANNEL-NUMBER和XOR-PEER-ADDRESS属性;
	   
   o  通道号在0x4000到0x7FFE（含）范围内;

   o  信道号当前没有绑定到不同的传输地址（相同的传输地址是可以的）;

   o  传输地址当前未绑定到不同的通道编号。

   如果这些测试中的任何一个失败，服务器将回复400（错误请求）错误。

   服务器可以对XOR-PEER-ADDRESS属性中允许的IP地址和端口值施加限制 - 
   如果不允许值，则服务器拒绝403（禁止）错误的请求。

   如果请求有效，但服务器由于某些容量限制或类似情况而无法满足请求，
   则服务器将回复508（容量不足）错误。

   否则，服务器将回复ChannelBind成功响应。 成功的ChannelBind响应中没有必需的属性。

   如果服务器可以满足请求，则服务器使用CHANNEL-NUMBER属性中的通道编号
   和XOR-PEER-ADDRESS属性中的传输地址创建或刷新通道绑定。
   
   服务器还会在XOR-PEER-ADDRESS属性中安装或刷新IP地址的权限，如第8节所述。

   注意：服务器不需要做任何特殊的事情来使用“无状态堆栈方法”
   通过UDP实现ChannelBind请求的幂等性。
   重新发送的ChannelBind请求将简单地刷新通道绑定和相应的权限。

   此外，客户端必须等待5分钟才能将先前绑定的通道号或对等地址绑定到不同的通道，
   从而消除了事务最初失败但重传成功的可能性。

11.3.  Receiving a ChannelBind Response

   当客户端收到ChannelBind成功响应时，
   它会更新其数据结构以记录通道绑定现在处于活动状态。
   它还会更新其数据结构，以记录已安装或刷新相应的权限。
    
   如果客户端收到ChannelBind失败响应，
   指示客户端和服务器之间的信道信息不同步（例如，意外的400“错误请求”响应），
   则建议客户端立即删除allocation 并重新开始新的allocation。

11.4.  The ChannelData Message

   ChannelData消息用于在客户端和服务器之间传送应用程序数据。 它具有以下格式：

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Channel Number        |            Length             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                       Application Data                        /
   /                                                               /
   |                                                               |
   |                               +-------------------------------+
   |                               |
   +-------------------------------+

   “通道编号”字段指定数据正在其上传输的通道的编号，
   从而指定正在发送或将要接收数据的对等方的地址。

   Length字段指定应用程序数据字段的字节长度（即，
   它不包括ChannelData标头的大小）。 请注意，0是有效长度。

   “Application Data ”字段携带客户端尝试发送给对等方的数据，或对等方发送给客户端的数据。

11.5.  Sending a ChannelData Message

   一旦客户端将信道绑定到对等体，则当客户端具有要发送给该对等体的数据时，
   它可以使用ChannelData消息或发送指令;
   也就是说，客户端没有义务在信道存在时使用该信道，
   并且可以在向对等体发送数据时自由地混合这两种消息类型。

   另一方面，如果某个通道已绑定到对等端，则必须使用ChannelData消息。

   ChannelData消息的字段按第11.4节中的描述填写。
   通过TCP和TLS-over-TCP，ChannelData消息必须填充到四个字节的倍数，
   以确保后续消息的对齐。 填充不会反映在ChannelData消息的长度字段中，
   因此ChannelData消息的实际大小（包括填充）是（4 +长度）
   向上舍入到最接近的4的倍数。
   在UDP上，填充不是必需的但是 可能包括在内。

   然后在与Allocation相关联的5元组上发送ChannelData消息。

11.6.  Receiving a ChannelData Message

  ChannelData消息的接收者使用前两位将其与STUN格式
  的消息区分开，如上所述。 如果消息使用保留范围（0x8000到0xFFFF）中的值，
  则会以静默方式丢弃该消息。

  如果在UDP数据报中接收到ChannelData消息，
  并且UDP数据报太短而不包含声明的ChannelData消息的长度
  （即，UDP报头长度字段值小于ChannelData报头长度字段值+ 4 + 8 ），
  然后默默地丢弃该消息。

  如果通过TCP或TLS-over-TCP接收ChannelData消息，
  则ChannelData消息的实际长度如第11.5节中所述。

   如果在未绑定到任何对等方的通道上收到ChannelData消息，
   则会以静默方式丢弃该消息。

   在客户端，如果客户端认为没有对对等方的活动权限，
   则建议客户端丢弃ChannelData消息。  
   在服务器上，收到的ChannelData消息绝不能刷新通道绑定或对等方的权限。

   在服务器上，如果未检测到错误，则服务器通过形成UDP数据报将应用程序数据中继到对等方，
   如下所示：

   o  源传输地址是allocation的中继传输地址，其中allocation由ChannelData消息到达的5元组决定;
     
   o  目的地传输地址是信道绑定的传输地址;
	   
   o  UDP头之后的数据是ChannelData消息的数据字段的内容。

   然后将生成的UDP数据报发送给对等体。
   请注意，如果ChannelData消息中的Length字段为0，
   则UDP数据报中将没有数据，但仍会形成并发送UDP数据报。

11.7.  Relaying Data from the Peer

   当服务器在与Allocation相关联的中继传输地址上接收UDP数据报时，
   服务器将按照第10.3节中的描述对其进行处理。 

   如果该部分指令应发送ChannelData消息
   （因为存在绑定到发送到UDP数据报的对等体的信道），
   则服务器形成并发送ChannelData消息，如第11.5节中所述。

12.  IP Header Fields

   本节描述了服务器在客户端和对等端之间进行中继时如何设置IP头中的各个字段，
    反之亦然。 本节中的描述适用于： 
   （a）当服务器向对等体发送UDP数据报时，或（b）当服务
   器通过UDP传输向客户端发送数据指示或ChannelData消息时。
   本节中的描述不适用于通过TCP或TLS传输从服务器发送到客户端的TURN消息。

   以下描述包含两部分：首选行为和备用行为。
   服务器应该实现首选行为，但如果某个特定字段不可能，
   那么它应该实现替代行为。

    生存时间（TTL）字段

      首选行为：如果传入值为0，则丢弃传入数据包。
	  除此以外，将传出的生存时间/跳数设置为小于传入值的一个。

      备用行为：将传出值设置为传出数据包的默认值。 
      差分服务代码点（DSCP）字段[RFC2474]

      首选行为：将传出值设置为传入值，
	  除非服务器包含差异化服务分类器和标记[RFC2474]。
	   
      备用行为：将传出值设置为固定值，默认情况下为Best Effort，除非另有配置。

      在这两种情况下，如果服务器紧邻差异化服务分类器和标记，
	  则DSCP可以设置为朝向分类器的方向上的任意值。

   显式拥塞通知（ECN）字段[RFC3168]

      首选行为：将传出值设置为传入值，除非服务器正在进行主动队列管理，
	  传入的ECN字段为ECT（1）（= 0b01）或ECT（0）（= 0b10），
	  服务器希望指示 已经经历了拥塞，
	  在这种情况下将输出值设置为CE（= 0b11）。

      备用行为：将传出值设置为Not-ECT（= 0b00）。

   IPv4 Fragmentation fields(IPv4碎片字段)

      首选行为：当服务器响应包含DONT-FRAGMENT属性的Send
	  指令向对等方发送数据包时，
	  请将传出IP标头中的DF位设置为1。

	  在所有其他情况下，当发送包含应用程序数据的传出数据包
	  （例如，Data指令，ChannelData消息或DONT-FRAGMENT属性未包含在发送指令中）时，
	  从包含该应用程序的传入数据包的DF位复制DF位 数据。
	    
      根据源自服务器的数据包，设置其他碎片字段（标识，更多片段，片段偏移）。
      备用行为：如首选行为中所述，除了始终假设传入DF位为0。

      In both the Preferred and Alternate Behaviors, the resulting
      packet may be too large for the outgoing link.  If this is the
      case, then the normal fragmentation rules apply [RFC1122].

   IPv4 Options（IPv4选项）

      首选行为：在没有任何IPv4选项的情况下发送传出数据包。
      替代行为：与首选相同。
	   
13.  New STUN Methods

   This section lists the codepoints for the new STUN methods defined in
   this specification.  See elsewhere in this document for the semantics
   of these new methods.

   0x003  :  Allocate          (only request/response semantics defined)
   0x004  :  Refresh           (only request/response semantics defined)
   0x006  :  Send              (only indication semantics defined)
   0x007  :  Data              (only indication semantics defined)
   0x008  :  CreatePermission  (only request/response semantics defined
   0x009  :  ChannelBind       (only request/response semantics defined)

14.  New STUN Attributes

   This STUN extension defines the following new attributes:

     0x000C: CHANNEL-NUMBER
     0x000D: LIFETIME
     0x0010: Reserved (was BANDWIDTH)
     0x0012: XOR-PEER-ADDRESS
     0x0013: DATA
     0x0016: XOR-RELAYED-ADDRESS
     0x0018: EVEN-PORT
     0x0019: REQUESTED-TRANSPORT
     0x001A: DONT-FRAGMENT
     0x0021: Reserved (was TIMER-VAL)
     0x0022: RESERVATION-TOKEN

   Some of these attributes have lengths that are not multiples of 4.
   By the rules of STUN, any attribute whose length is not a multiple of
   4 bytes MUST be immediately followed by 1 to 3 padding bytes to
   ensure the next attribute (if any) would start on a 4-byte boundary
   (see [RFC5389]).

14.1.  CHANNEL-NUMBER

   The CHANNEL-NUMBER attribute contains the number of the channel.  The
   value portion of this attribute is 4 bytes long and consists of a 16-
   bit unsigned integer, followed by a two-octet RFFU (Reserved For
   Future Use) field, which MUST be set to 0 on transmission and MUST be
   ignored on reception.

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |        Channel Number         |         RFFU = 0              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	  
14.2.  LIFETIME

   The LIFETIME attribute represents the duration for which the server
   will maintain an allocation in the absence of a refresh.  The value
   portion of this attribute is 4-bytes long and consists of a 32-bit
   unsigned integral value representing the number of seconds remaining
   until expiration.

14.3.  XOR-PEER-ADDRESS

   The XOR-PEER-ADDRESS specifies the address and port of the peer as
   seen from the TURN server.  (For example, the peer's server-reflexive
   transport address if the peer is behind a NAT.)  It is encoded in the
   same way as XOR-MAPPED-ADDRESS [RFC5389].

14.4.  DATA

   DATA属性出现在所有发送和数据指示中。
  此属性的值部分是可变长度，由应用程序数据组成
  （即，如果数据是在客户端和对等端之间直接发送的，则紧跟UDP头的数据）。
  如果此属性的长度不是4的倍数，则必须在此属性后添加填充。

14.5.  XOR-RELAYED-ADDRESS

   The XOR-RELAYED-ADDRESS is present in Allocate responses.  It
   specifies the address and port that the server allocated to the
   client.  It is encoded in the same way as XOR-MAPPED-ADDRESS
   [RFC5389].

14.6.  EVEN-PORT

   This attribute allows the client to request that the port in the
   relayed transport address be even, and (optionally) that the server
   reserve the next-higher port number.  The value portion of this
   attribute is 1 byte long.  Its format is:
    
      0
      0 1 2 3 4 5 6 7
     +-+-+-+-+-+-+-+-+
     |R|    RFFU     |
     +-+-+-+-+-+-+-+-+

   The value contains a single 1-bit flag:

   R: If 1, the server is requested to reserve the next-higher port
      number (on the same IP address) for a subsequent allocation.  If
      0, no such reservation is requested.

   The other 7 bits of the attribute's value must be set to zero on
   transmission and ignored on reception.

   Since the length of this attribute is not a multiple of 4, padding
   must immediately follow this attribute.

14.7.  REQUESTED-TRANSPORT

   This attribute is used by the client to request a specific transport
   protocol for the allocated transport address.  The value of this
   attribute is 4 bytes with the following format:
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |    Protocol   |                    RFFU                       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The Protocol field specifies the desired protocol.  The codepoints
   used in this field are taken from those allowed in the Protocol field
   in the IPv4 header and the NextHeader field in the IPv6 header
   [Protocol-Numbers].  This specification only allows the use of
   codepoint 17 (User Datagram Protocol).

   The RFFU field MUST be set to zero on transmission and MUST be
   ignored on reception.  It is reserved for future uses.

14.8.  DONT-FRAGMENT

   This attribute is used by the client to request that the server set
   the DF (Don't Fragment) bit in the IP header when relaying the
   application data onward to the peer.  This attribute has no value
   part and thus the attribute length field is 0.
    

14.9.  RESERVATION-TOKEN

   The RESERVATION-TOKEN attribute contains a token that uniquely
   identifies a relayed transport address being held in reserve by the
   server.  The server includes this attribute in a success response to
   tell the client about the token, and the client includes this
   attribute in a subsequent Allocate request to request the server use
   that relayed transport address for the allocation.

   The attribute value is 8 bytes and contains the token value.

15.  New STUN Error Response Codes

   This document defines the following new error response codes:

   403  (Forbidden): The request was valid but cannot be performed due
      to administrative or similar restrictions.

   437  (Allocation Mismatch): A request was received by the server that
      requires an allocation to be in place, but no allocation exists,
      or a request was received that requires no allocation, but an
      allocation exists.

   441  (Wrong Credentials): The credentials in the (non-Allocate)
      request do not match those used to create the allocation.

   442  (Unsupported Transport Protocol): The Allocate request asked the
      server to use a transport protocol between the server and the peer
      that the server does not support.  NOTE: This does NOT refer to
      the transport protocol used in the 5-tuple.

   486  (Allocation Quota Reached): No more allocations using this
      username can be created at the present time.

   508  (Insufficient Capacity): The server is unable to carry out the
      request due to some capacity limit being reached.  In an Allocate
      response, this could be due to the server having no more relayed
      transport addresses available at that time, having none with the
      requested properties, or the one that corresponds to the specified
      reservation token is not available.

16.  Detailed Example

   This section gives an example of the use of TURN, showing in detail
   the contents of the messages exchanged.  The example uses the network
   diagram shown in the Overview (Figure 1).

    
   For each message, the attributes included in the message and their
   values are shown.  For convenience, values are shown in a human-
   readable format rather than showing the actual octets; for example,
   "XOR-RELAYED-ADDRESS=192.0.2.15:9000" shows that the XOR-RELAYED-
   ADDRESS attribute is included with an address of 192.0.2.15 and a
   port of 9000, here the address and port are shown before the xor-ing
   is done.  For attributes with string-like values (e.g.,
   SOFTWARE="Example client, version 1.03" and
   NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"), the value of the attribute
   is shown in quotes for readability, but these quotes do not appear in
   the actual value.

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |--- Allocate request -------------->|             |             |
    |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
    |    SOFTWARE="Example client, version 1.03"       |             |
    |    LIFETIME=3600 (1 hour)          |             |             |
    |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
    |    DONT-FRAGMENT                   |             |             |
    |                                    |             |             |
    |<-- Allocate error response --------|             |             |
    |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    ERROR-CODE=401 (Unauthorized)   |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |                                    |             |             |
    |--- Allocate request -------------->|             |             |
    |    Transaction-Id=0xC271E932AD7446A32C234492     |             |
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    LIFETIME=3600 (1 hour)          |             |             |
    |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
    |    DONT-FRAGMENT                   |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- Allocate success response ------|             |             |
    |    Transaction-Id=0xC271E932AD7446A32C234492     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    LIFETIME=1200 (20 minutes)      |             |             |
    |    XOR-RELAYED-ADDRESS=192.0.2.15:50000          |             |
    |    XOR-MAPPED-ADDRESS=192.0.2.1:7000             |             |
    |    MESSAGE-INTEGRITY=...           |             |             |

	 
   The client begins by selecting a host transport address to use for
   the TURN session; in this example, the client has selected 10.1.1.2:
   49721 as shown in Figure 1.  The client then sends an Allocate
   request to the server at the server transport address.  The client
   randomly selects a 96-bit transaction id of
   0xA56250D3F17ABE679422DE85 for this transaction; this is encoded in
   the transaction id field in the fixed header.  The client includes a
   SOFTWARE attribute that gives information about the client's
   software; here the value is "Example client, version 1.03" to
   indicate that this is version 1.03 of something called the Example
   client.  The client includes the LIFETIME attribute because it wishes
   the allocation to have a longer lifetime than the default of 10
   minutes; the value of this attribute is 3600 seconds, which
   corresponds to 1 hour.  The client must always include a REQUESTED-
   TRANSPORT attribute in an Allocate request and the only value allowed
   by this specification is 17, which indicates UDP transport between
   the server and the peers.  The client also includes the DONT-FRAGMENT
   attribute because it wishes to use the DONT-FRAGMENT attribute later
   in Send indications; this attribute consists of only an attribute
   header, there is no value part.  We assume the client has not
   recently interacted with the server, thus the client does not include
   USERNAME, REALM, NONCE, or MESSAGE-INTEGRITY attribute.  Finally,
   note that the order of attributes in a message is arbitrary (except
   for the MESSAGE-INTEGRITY and FINGERPRINT attributes) and the client
   could have used a different order.

   Servers require any request to be authenticated.  Thus, when the
   server receives the initial Allocate request, it rejects the request
   because the request does not contain the authentication attributes.
   Following the procedures of the long-term credential mechanism of
   STUN [RFC5389], the server includes an ERROR-CODE attribute with a
   value of 401 (Unauthorized), a REALM attribute that specifies the
   authentication realm used by the server (in this case, the server's
   domain "example.com"), and a nonce value in a NONCE attribute.  The
   server also includes a SOFTWARE attribute that gives information
   about the server's software.

   The client, upon receipt of the 401 error, re-attempts the Allocate
   request, this time including the authentication attributes.  The
   client selects a new transaction id, and then populates the new
   Allocate request with the same attributes as before.  The client
   includes a USERNAME attribute and uses the realm value received from
   the server to help it determine which value to use; here the client
   is configured to use the username "George" for the realm
   "example.com".  The client also includes the REALM and NONCE
   attributes, which are just copied from the 401 error response.
   Finally, the client includes a MESSAGE-INTEGRITY attribute as the
   last attribute in the message, whose value is a Hashed Message
    
   Authentication Code - Secure Hash Algorithm 1 (HMAC-SHA1) hash over
   the contents of the message (shown as just "..." above); this HMAC-
   SHA1 computation includes a password value.  Thus, an attacker cannot
   compute the message integrity value without somehow knowing the
   secret password.

   The server, upon receipt of the authenticated Allocate request,
   checks that everything is OK, then creates an allocation.  The server
   replies with an Allocate success response.  The server includes a
   LIFETIME attribute giving the lifetime of the allocation; here, the
   server has reduced the client's requested 1-hour lifetime to just 20
   minutes, because this particular server doesn't allow lifetimes
   longer than 20 minutes.  The server includes an XOR-RELAYED-ADDRESS
   attribute whose value is the relayed transport address of the
   allocation.  The server includes an XOR-MAPPED-ADDRESS attribute
   whose value is the server-reflexive address of the client; this value
   is not used otherwise in TURN but is returned as a convenience to the
   client.  The server includes a MESSAGE-INTEGRITY attribute to
   authenticate the response and to ensure its integrity; note that the
   response does not contain the USERNAME, REALM, and NONCE attributes.
   The server also includes a SOFTWARE attribute.

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- CreatePermission request ------>|             |             |
    |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:0  |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- CreatePermission success resp.--|             |             |
    |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
    |    MESSAGE-INTEGRITY=...           |             |             |

   The client then creates a permission towards Peer A in preparation
   for sending it some application data.  This is done through a
   CreatePermission request.  The XOR-PEER-ADDRESS attribute contains
   the IP address for which a permission is established (the IP address
   of peer A); note that the port number in the attribute is ignored
   when used in a CreatePermission request, and here it has been set to
   0; also, note how the client uses Peer A's server-reflexive IP
   address and not its (private) host address.  The client uses the same
   username, realm, and nonce values as in the previous request on the
   allocation.  Though it is allowed to do so, the client has chosen not
   to include a SOFTWARE attribute in this request.
    
   The server receives the CreatePermission request, creates the
   corresponding permission, and then replies with a CreatePermission
   success response.  Like the client, the server chooses not to include
   the SOFTWARE attribute in its reply.  Again, note how success
   responses contain a MESSAGE-INTEGRITY attribute (assuming the server
   uses the long-term credential mechanism), but no USERNAME, REALM, and
   NONCE attributes.

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- Send indication --------------->|             |             |
    |    Transaction-Id=0x1278E9ACA2711637EF7D3328     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |
    |    DONT-FRAGMENT                   |             |             |
    |    DATA=...                        |             |             |
    |                                    |-- UDP dgm ->|             |
    |                                    |  data=...   |             |
    |                                    |             |             |
    |                                    |<- UDP dgm --|             |
    |                                    |  data=...   |             |
    |<-- Data indication ----------------|             |             |
    |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |
    |    DATA=...                        |             |             |

   The client now sends application data to Peer A using a Send
   indication.  Peer A's server-reflexive transport address is specified
   in the XOR-PEER-ADDRESS attribute, and the application data (shown
   here as just "...") is specified in the DATA attribute.  The client
   is doing a form of path MTU discovery at the application layer and
   thus specifies (by including the DONT-FRAGMENT attribute) that the
   server should set the DF bit in the UDP datagram to send to the peer.
   Indications cannot be authenticated using the long-term credential
   mechanism of STUN, so no MESSAGE-INTEGRITY attribute is included in
   the message.  An application wishing to ensure that its data is not
   altered or forged must integrity-protect its data at the application
   level.

   Upon receipt of the Send indication, the server extracts the
   application data and sends it in a UDP datagram to Peer A, with the
   relayed transport address as the source transport address of the
   datagram, and with the DF bit set as requested.  Note that, had the
   client not previously established a permission for Peer A's server-
   reflexive IP address, then the server would have silently discarded
   the Send indication instead.
    
   Peer A then replies with its own UDP datagram containing application
   data.  The datagram is sent to the relayed transport address on the
   server.  When this arrives, the server creates a Data indication
   containing the source of the UDP datagram in the XOR-PEER-ADDRESS
   attribute, and the data from the UDP datagram in the DATA attribute.
   The resulting Data indication is then sent to the client.

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- ChannelBind request ----------->|             |             |
    |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
    |    CHANNEL-NUMBER=0x4000           |             |             |
    |    XOR-PEER-ADDRESS=192.0.2.210:49191            |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- ChannelBind success response ---|             |             |
    |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
    |    MESSAGE-INTEGRITY=...           |             |             |

   The client now binds a channel to Peer B, specifying a free channel
   number (0x4000) in the CHANNEL-NUMBER attribute, and Peer B's
   transport address in the XOR-PEER-ADDRESS attribute.  As before, the
   client re-uses the username, realm, and nonce from its last request
   in the message.

   Upon receipt of the request, the server binds the channel number to
   the peer, installs a permission for Peer B's IP address, and then
   replies with ChannelBind success response.

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- ChannelData ------------------->|             |             |
    |    Channel-number=0x4000           |--- UDP datagram --------->|
    |    Data=...                        |    Data=...               |
    |                                    |             |             |
    |                                    |<-- UDP datagram ----------|
    |                                    |    Data=... |             |
    |<-- ChannelData --------------------|             |             |
    |    Channel-number=0x4000           |             |             |
    |    Data=...                        |             |             |

   The client now sends a ChannelData message to the server with data
   destined for Peer B.  The ChannelData message is not a STUN message,
   and thus has no transaction id.  Instead, it has only three fields: a
   channel number, data, and data length; here the channel number field
    
   is 0x4000 (the channel the client just bound to Peer B).  When the
   server receives the ChannelData message, it checks that the channel
   is currently bound (which it is) and then sends the data onward to
   Peer B in a UDP datagram, using the relayed transport address as the
   source transport address and 192.0.2.210:49191 (the value of the XOR-
   PEER-ADDRESS attribute in the ChannelBind request) as the destination
   transport address.

   Later, Peer B sends a UDP datagram back to the relayed transport
   address.  This causes the server to send a ChannelData message to the
   client containing the data from the UDP datagram.  The server knows
   to which client to send the ChannelData message because of the
   relayed transport address at which the UDP datagram arrived, and
   knows to use channel 0x4000 because this is the channel bound to
   192.0.2.210:49191.  Note that if there had not been any channel
   number bound to that address, the server would have used a Data
   indication instead.

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- Refresh request --------------->|             |             |
    |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- Refresh error response ---------|             |             |
    |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    ERROR-CODE=438 (Stale Nonce)    |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="npSw1Xw239bBwGYhjNWgz2yH47sxB2j"       |             |
    |                                    |             |             |
    |--- Refresh request --------------->|             |             |
    |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="npSw1Xw239bBwGYhjNWgz2yH47sxB2j"       |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- Refresh success response -------|             |             |
    |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    LIFETIME=600 (10 minutes)       |             |             |

	 
   Sometime before the 20 minute lifetime is up, the client refreshes
   the allocation.  This is done using a Refresh request.  As before,
   the client includes the latest username, realm, and nonce values in
   the request.  The client also includes the SOFTWARE attribute,
   following the recommended practice of always including this attribute
   in Allocate and Refresh messages.  When the server receives the
   Refresh request, it notices that the nonce value has expired, and so
   replies with 438 (Stale Nonce) error given a new nonce value.  The
   client then reattempts the request, this time with the new nonce
   value.  This second attempt is accepted, and the server replies with
   a success response.  Note that the client did not include a LIFETIME
   attribute in the request, so the server refreshes the allocation for
   the default lifetime of 10 minutes (as can be seen by the LIFETIME
   attribute in the success response).

17.  Security Considerations

   This section considers attacks that are possible in a TURN
   deployment, and discusses how they are mitigated by mechanisms in the
   protocol or recommended practices in the implementation.

   Most of the attacks on TURN are mitigated by the server requiring
   requests be authenticated.  Thus, this specification requires the use
   of authentication.  The mandatory-to-implement mechanism is the long-
   term credential mechanism of STUN.  Other authentication mechanisms
   of equal or stronger security properties may be used.  However, it is
   important to ensure that they can be invoked in an inter-operable
   way.

17.1.  Outsider Attacks

   Outsider attacks are ones where the attacker has no credentials in
   the system, and is attempting to disrupt the service seen by the
   client or the server.

17.1.1.  Obtaining Unauthorized Allocations

   An attacker might wish to obtain allocations on a TURN server for any
   number of nefarious purposes.  A TURN server provides a mechanism for
   sending and receiving packets while cloaking the actual IP address of
   the client.  This makes TURN servers an attractive target for
   attackers who wish to use it to mask their true identity.

   An attacker might also wish to simply utilize the services of a TURN
   server without paying for them.  Since TURN services require
   resources from the provider, it is anticipated that their usage will
   come with a cost.
    
   These attacks are prevented using the long-term credential mechanism,
   which allows the TURN server to determine the identity of the
   requestor and whether the requestor is allowed to obtain the
   allocation.

17.1.2.  Offline Dictionary Attacks

   The long-term credential mechanism used by TURN is subject to offline
   dictionary attacks.  An attacker that is capable of eavesdropping on
   a message exchange between a client and server can determine the
   password by trying a number of candidate passwords and seeing if one
   of them is correct.  This attack works when the passwords are low
   entropy, such as a word from the dictionary.  This attack can be
   mitigated by using strong passwords with large entropy.  In
   situations where even stronger mitigation is required, TLS transport
   between the client and the server can be used.

17.1.3.  Faked Refreshes and Permissions

   An attacker might wish to attack an active allocation by sending it a
   Refresh request with an immediate expiration, in order to delete it
   and disrupt service to the client.  This is prevented by
   authentication of refreshes.  Similarly, an attacker wishing to send
   CreatePermission requests to create permissions to undesirable
   destinations is prevented from doing so through authentication.  The
   motivations for such an attack are described in Section 17.2.

17.1.4.  Fake Data

   An attacker might wish to send data to the client or the peer, as if
   they came from the peer or client, respectively.  To do that, the
   attacker can send the client a faked Data Indication or ChannelData
   message, or send the TURN server a faked Send Indication or
   ChannelData message.

   Since indications and ChannelData messages are not authenticated,
   this attack is not prevented by TURN.  However, this attack is
   generally present in IP-based communications and is not substantially
   worsened by TURN.  Consider a normal, non-TURN IP session between
   hosts A and B.  An attacker can send packets to B as if they came
   from A by sending packets towards A with a spoofed IP address of B.
   This attack requires the attacker to know the IP addresses of A and
   B.  With TURN, an attacker wishing to send packets towards a client
   using a Data indication needs to know its IP address (and port), the
   IP address and port of the TURN server, and the IP address and port
   of the peer (for inclusion in the XOR-PEER-ADDRESS attribute).  To
   send a fake ChannelData message to a client, an attacker needs to
   know the IP address and port of the client, the IP address and port
    
   of the TURN server, and the channel number.  This particular
   combination is mildly more guessable than in the non-TURN case.

   These attacks are more properly mitigated by application-layer
   authentication techniques.  In the case of real-time traffic, usage
   of SRTP [RFC3711] prevents these attacks.

   In some situations, the TURN server may be situated in the network
   such that it is able to send to hosts to which the client cannot
   directly send.  This can happen, for example, if the server is
   located behind a firewall that allows packets from outside the
   firewall to be delivered to the server, but not to other hosts behind
   the firewall.  In these situations, an attacker could send the server
   a Send indication with an XOR-PEER-ADDRESS attribute containing the
   transport address of one of the other hosts behind the firewall.  If
   the server was to allow relaying of traffic to arbitrary peers, then
   this would provide a way for the attacker to attack arbitrary hosts
   behind the firewall.

   To mitigate this attack, TURN requires that the client establish a
   permission to a host before sending it data.  Thus, an attacker can
   only attack hosts with which the client is already communicating,
   unless the attacker is able to create authenticated requests.
   Furthermore, the server administrator may configure the server to
   restrict the range of IP addresses and ports to which it will relay
   data.  To provide even greater security, the server administrator can
   require that the client use TLS for all communication between the
   client and the server.

17.1.5.  Impersonating a Server

   When a client learns a relayed address from a TURN server, it uses
   that relayed address in application protocols to receive traffic.
   Therefore, an attacker wishing to intercept or redirect that traffic
   might try to impersonate a TURN server and provide the client with a
   faked relayed address.

   This attack is prevented through the long-term credential mechanism,
   which provides message integrity for responses in addition to
   verifying that they came from the server.  Furthermore, an attacker
   cannot replay old server responses as the transaction id in the STUN
   header prevents this.  Replay attacks are further thwarted through
   frequent changes to the nonce value.

    
17.1.6.  Eavesdropping Traffic

   TURN concerns itself primarily with authentication and message
   integrity.  Confidentiality is only a secondary concern, as TURN
   control messages do not include information that is particularly
   sensitive.  The primary protocol content of the messages is the IP
   address of the peer.  If it is important to prevent an eavesdropper
   on a TURN connection from learning this, TURN can be run over TLS.

   Confidentiality for the application data relayed by TURN is best
   provided by the application protocol itself, since running TURN over
   TLS does not protect application data between the server and the
   peer.  If confidentiality of application data is important, then the
   application should encrypt or otherwise protect its data.  For
   example, for real-time media, confidentiality can be provided by
   using SRTP.

17.1.7.  TURN Loop Attack

   An attacker might attempt to cause data packets to loop indefinitely
   between two TURN servers.  The attack goes as follows.  First, the
   attacker sends an Allocate request to server A, using the source
   address of server B.  Server A will send its response to server B,
   and for the attack to succeed, the attacker must have the ability to
   either view or guess the contents of this response, so that the
   attacker can learn the allocated relayed transport address.  The
   attacker then sends an Allocate request to server B, using the source
   address of server A.  Again, the attacker must be able to view or
   guess the contents of the response, so it can send learn the
   allocated relayed transport address.  Using the same spoofed source
   address technique, the attacker then binds a channel number on server
   A to the relayed transport address on server B, and similarly binds
   the same channel number on server B to the relayed transport address
   on server A.  Finally, the attacker sends a ChannelData message to
   server A.

   The result is a data packet that loops from the relayed transport
   address on server A to the relayed transport address on server B,
   then from server B's transport address to server A's transport
   address, and then around the loop again.

   This attack is mitigated as follows.  By requiring all requests to be
   authenticated and/or by randomizing the port number allocated for the
   relayed transport address, the server forces the attacker to either
   intercept or view responses sent to a third party (in this case, the
   other server) so that the attacker can authenticate the requests and
   learn the relayed transport address.  Without one of these two
   measures, an attacker can guess the contents of the responses without
    
   needing to see them, which makes the attack much easier to perform.
   Furthermore, by requiring authenticated requests, the server forces
   the attacker to have credentials acceptable to the server, which
   turns this from an outsider attack into an insider attack and allows
   the attack to be traced back to the client initiating it.

   The attack can be further mitigated by imposing a per-username limit
   on the bandwidth used to relay data by allocations owned by that
   username, to limit the impact of this attack on other allocations.
   More mitigation can be achieved by decrementing the TTL when relaying
   data packets (if the underlying OS allows this).

17.2.  Firewall Considerations

   A key security consideration of TURN is that TURN should not weaken
   the protections afforded by firewalls deployed between a client and a
   TURN server.  It is anticipated that TURN servers will often be
   present on the public Internet, and clients may often be inside
   enterprise networks with corporate firewalls.  If TURN servers
   provide a 'backdoor' for reaching into the enterprise, TURN will be
   blocked by these firewalls.

   TURN servers therefore emulate the behavior of NAT devices that
   implement address-dependent filtering [RFC4787], a property common in
   many firewalls as well.  When a NAT or firewall implements this
   behavior, packets from an outside IP address are only allowed to be
   sent to an internal IP address and port if the internal IP address
   and port had recently sent a packet to that outside IP address.  TURN
   servers introduce the concept of permissions, which provide exactly
   this same behavior on the TURN server.  An attacker cannot send a
   packet to a TURN server and expect it to be relayed towards the
   client, unless the client has tried to contact the attacker first.

   It is important to note that some firewalls have policies that are
   even more restrictive than address-dependent filtering.  Firewalls
   can also be configured with address- and port-dependent filtering, or
   can be configured to disallow inbound traffic entirely.  In these
   cases, if a client is allowed to connect the TURN server,
   communications to the client will be less restrictive than what the
   firewall would normally allow.

17.2.1.  Faked Permissions

   In firewalls and NAT devices, permissions are granted implicitly
   through the traversal of a packet from the inside of the network
   towards the outside peer.  Thus, a permission cannot, by definition,
   be created by any entity except one inside the firewall or NAT.  With
   TURN, this restriction no longer holds.  Since the TURN server sits
    
   outside the firewall, at attacker outside the firewall can now send a
   message to the TURN server and try to create a permission for itself.

   This attack is prevented because all messages that create permissions
   (i.e., ChannelBind and CreatePermission) are authenticated.

17.2.2.  Blacklisted IP Addresses

   Many firewalls can be configured with blacklists that prevent a
   client behind the firewall from sending packets to, or receiving
   packets from, ranges of blacklisted IP addresses.  This is
   accomplished by inspecting the source and destination addresses of
   packets entering and exiting the firewall, respectively.

   This feature is also present in TURN, since TURN servers are allowed
   to arbitrarily restrict the range of addresses of peers that they
   will relay to.

17.2.3.  Running Servers on Well-Known Ports

   A malicious client behind a firewall might try to connect to a TURN
   server and obtain an allocation which it then uses to run a server.
   For example, a client might try to run a DNS server or FTP server.

   This is not possible in TURN.  A TURN server will never accept
   traffic from a peer for which the client has not installed a
   permission.  Thus, peers cannot just connect to the allocated port in
   order to obtain the service.

17.3.  Insider Attacks

   In insider attacks, a client has legitimate credentials but defies
   the trust relationship that goes with those credentials.  These
   attacks cannot be prevented by cryptographic means but need to be
   considered in the design of the protocol.

17.3.1.  DoS against TURN Server

   A client wishing to disrupt service to other clients might obtain an
   allocation and then flood it with traffic, in an attempt to swamp the
   server and prevent it from servicing other legitimate clients.  This
   is mitigated by the recommendation that the server limit the amount
   of bandwidth it will relay for a given username.  This won't prevent
   a client from sending a large amount of traffic, but it allows the
   server to immediately discard traffic in excess.

   Since each allocation uses a port number on the IP address of the
   TURN server, the number of allocations on a server is finite.  An
    
   attacker might attempt to consume all of them by requesting a large
   number of allocations.  This is prevented by the recommendation that
   the server impose a limit of the number of allocations active at a
   time for a given username.

17.3.2.  Anonymous Relaying of Malicious Traffic

   TURN servers provide a degree of anonymization.  A client can send
   data to peers without revealing its own IP address.  TURN servers may
   therefore become attractive vehicles for attackers to launch attacks
   against targets without fear of detection.  Indeed, it is possible
   for a client to chain together multiple TURN servers, such that any
   number of relays can be used before a target receives a packet.

   Administrators who are worried about this attack can maintain logs
   that capture the actual source IP and port of the client, and perhaps
   even every permission that client installs.  This will allow for
   forensic tracing to determine the original source, should it be
   discovered that an attack is being relayed through a TURN server.

17.3.3.  Manipulating Other Allocations

   An attacker might attempt to disrupt service to other users of the
   TURN server by sending Refresh requests or CreatePermission requests
   that (through source address spoofing) appear to be coming from
   another user of the TURN server.  TURN prevents this by requiring
   that the credentials used in CreatePermission, Refresh, and
   ChannelBind messages match those used to create the initial
   allocation.  Thus, the fake requests from the attacker will be
   rejected.

17.4.  Other Considerations

   Any relay addresses learned through an Allocate request will not
   operate properly with IPsec Authentication Header (AH) [RFC4302] in
   transport or tunnel mode.  However, tunnel-mode IPsec Encapsulating
   Security Payload (ESP) [RFC4303] should still operate.

18.  IANA Considerations

   Since TURN is an extension to STUN [RFC5389], the methods,
   attributes, and error codes defined in this specification are new
   methods, attributes, and error codes for STUN.  IANA has added these
   new protocol elements to the IANA registry of STUN protocol elements.

   The codepoints for the new STUN methods defined in this specification
   are listed in Section 13.
    

   The codepoints for the new STUN attributes defined in this
   specification are listed in Section 14.

   The codepoints for the new STUN error codes defined in this
   specification are listed in Section 15.

   IANA has allocated the SRV service name of "turn" for TURN over UDP
   or TCP, and the service name of "turns" for TURN over TLS.

   IANA has created a registry for TURN channel numbers, initially
   populated as follows:

      0x0000 through 0x3FFF: Reserved and not available for use, since
      they conflict with the STUN header.

      0x4000 through 0x7FFF: A TURN implementation is free to use
      channel numbers in this range.

      0x8000 through 0xFFFF: Unassigned.

   Any change to this registry must be made through an IETF Standards
   Action.

19.  IAB Considerations

   The IAB has studied the problem of "Unilateral Self Address Fixing"
   (UNSAF), which is the general process by which a client attempts to
   determine its address in another realm on the other side of a NAT
   through a collaborative protocol-reflection mechanism [RFC3424].  The
   TURN extension is an example of a protocol that performs this type of
   function.  The IAB has mandated that any protocols developed for this
   purpose document a specific set of considerations.  These
   considerations and the responses for TURN are documented in this
   section.

   Consideration 1: Precise definition of a specific, limited-scope
   problem that is to be solved with the UNSAF proposal.  A short-term
   fix should not be generalized to solve other problems.  Such
   generalizations lead to the prolonged dependence on and usage of the
   supposed short-term fix -- meaning that it is no longer accurate to
   call it "short-term".

   Response: TURN is a protocol for communication between a relay (=
   TURN server) and its client.  The protocol allows a client that is
   behind a NAT to obtain and use a public IP address on the relay.  As
   a convenience to the client, TURN also allows the client to determine
   its server-reflexive transport address.
    
   Consideration 2: Description of an exit strategy/transition plan.
   The better short-term fixes are the ones that will naturally see less
   and less use as the appropriate technology is deployed.

   Response: TURN will no longer be needed once there are no longer any
   NATs.  Unfortunately, as of the date of publication of this document,
   it no longer seems very likely that NATs will go away any time soon.
   However, the need for TURN will also decrease as the number of NATs
   with the mapping property of Endpoint-Independent Mapping [RFC4787]
   increases.

   Consideration 3: Discussion of specific issues that may render
   systems more "brittle".  For example, approaches that involve using
   data at multiple network layers create more dependencies, increase
   debugging challenges, and make it harder to transition.

   Response: TURN is "brittle" in that it requires the NAT bindings
   between the client and the server to be maintained unchanged for the
   lifetime of the allocation.  This is typically done using keep-
   alives.  If this is not done, then the client will lose its
   allocation and can no longer exchange data with its peers.

   Consideration 4: Identify requirements for longer-term, sound
   technical solutions; contribute to the process of finding the right
   longer-term solution.

   Response: The need for TURN will be reduced once NATs implement the
   recommendations for NAT UDP behavior documented in [RFC4787].
   Applications are also strongly urged to use ICE [RFC5245] to
   communicate with peers; though ICE uses TURN, it does so only as a
   last resort, and uses it in a controlled manner.

   Consideration 5: Discussion of the impact of the noted practical
   issues with existing deployed NATs and experience reports.

   Response: Some NATs deployed today exhibit a mapping behavior other
   than Endpoint-Independent mapping.  These NATs are difficult to work
   with, as they make it difficult or impossible for protocols like ICE
   to use server-reflexive transport addresses on those NATs.  A client
   behind such a NAT is often forced to use a relay protocol like TURN
   because "UDP hole punching" techniques [RFC5128] do not work.

20.  Acknowledgements

   The authors would like to thank the various participants in the
   BEHAVE working group for their many comments on this document.  Marc
   Petit-Huguenin, Remi Denis-Courmont, Jason Fischl, Derek MacDonald,
   Scott Godin, Cullen Jennings, Lars Eggert, Magnus Westerlund, Benny
    

   Prijono, and Eric Rescorla have been particularly helpful, with Eric
   suggesting the channel allocation mechanism, Cullen suggesting an
   earlier version of the EVEN-PORT mechanism, and Marc spending many
   hours implementing the preliminary versions to look for problems.
   Christian Huitema was an early contributor to this document and was a
   co-author on the first few versions.  Finally, the authors would like
   to thank Dan Wing for both his contributions to the text and his huge
   help in restarting progress on this document after work had stalled.

21.  References

21.1.  Normative References

   [RFC5389]            Rosenberg, J., Mahy, R., Matthews, P., and D.
                        Wing, "Session Traversal Utilities for NAT
                        (STUN)", RFC 5389, October 2008.

   [RFC2119]            Bradner, S., "Key words for use in RFCs to
                        Indicate Requirement Levels", BCP 14, RFC 2119,
                        March 1997.

   [RFC2474]            Nichols, K., Blake, S., Baker, F., and D. Black,
                        "Definition of the Differentiated Services Field
                        (DS Field) in the IPv4 and IPv6 Headers",
                        RFC 2474, December 1998.

   [RFC3168]            Ramakrishnan, K., Floyd, S., and D. Black, "The
                        Addition of Explicit Congestion Notification
                        (ECN) to IP", RFC 3168, September 2001.

   [RFC1122]            Braden, R., "Requirements for Internet Hosts -
                        Communication Layers", STD 3, RFC 1122,
                        October 1989.

21.2.  Informative References

   [RFC1191]            Mogul, J. and S. Deering, "Path MTU discovery",
                        RFC 1191, November 1990.

   [RFC0791]            Postel, J., "Internet Protocol", STD 5, RFC 791,
                        September 1981.

   [RFC1918]            Rekhter, Y., Moskowitz, R., Karrenberg, D.,
                        Groot, G., and E. Lear, "Address Allocation for
                        Private Internets", BCP 5, RFC 1918,
                        February 1996.
 

   [RFC3424]            Daigle, L. and IAB, "IAB Considerations for
                        UNilateral Self-Address Fixing (UNSAF) Across
                        Network Address Translation", RFC 3424,
                        November 2002.

   [RFC4787]            Audet, F. and C. Jennings, "Network Address
                        Translation (NAT) Behavioral Requirements for
                        Unicast UDP", BCP 127, RFC 4787, January 2007.

   [RFC5245]            Rosenberg, J., "Interactive Connectivity
                        Establishment (ICE): A Protocol for Network
                        Address Translator (NAT) Traversal for
                        Offer/Answer Protocols", RFC 5245, April 2010.

   [TURN-TCP]           Perreault, S. and J. Rosenberg, "Traversal Using
                        Relays around NAT (TURN) Extensions for TCP
                        Allocations", Work in Progress, March 2010.

   [TURN-IPv6]          Perreault, S., Camarillo, G., and O. Novo,
                        "Traversal Using Relays around NAT (TURN)
                        Extension for IPv6", Work in Progress, March
                        2010.

   [TSVWG-PORT]         Larsen, M. and F. Gont, "Port Randomization",
                        Work in Progress, April 2010.

   [RFC5128]            Srisuresh, P., Ford, B., and D. Kegel, "State of
                        Peer-to-Peer (P2P) Communication across Network
                        Address Translators (NATs)", RFC 5128,
                        March 2008.

   [RFC1928]            Leech, M., Ganis, M., Lee, Y., Kuris, R.,
                        Koblas, D., and L. Jones, "SOCKS Protocol
                        Version 5", RFC 1928, March 1996.

   [RFC3550]            Schulzrinne, H., Casner, S., Frederick, R., and
                        V. Jacobson, "RTP: A Transport Protocol for
                        Real-Time Applications", STD 64, RFC 3550,
                        July 2003.

   [RFC3711]            Baugher, M., McGrew, D., Naslund, M., Carrara,
                        E., and K. Norrman, "The Secure Real-time
                        Transport Protocol (SRTP)", RFC 3711,
                        March 2004.

   [RFC4302]            Kent, S., "IP Authentication Header", RFC 4302,
                        December 2005.
 
   [RFC4303]            Kent, S., "IP Encapsulating Security Payload
                        (ESP)", RFC 4303, December 2005.

   [RFC4821]            Mathis, M. and J. Heffner, "Packetization Layer
                        Path MTU Discovery", RFC 4821, March 2007.

   [RFC3261]            Rosenberg, J., Schulzrinne, H., Camarillo, G.,
                        Johnston, A., Peterson, J., Sparks, R., Handley,
                        M., and E. Schooler, "SIP: Session Initiation
                        Protocol", RFC 3261, June 2002.

   [MMUSIC-ICE-NONSIP]  Rosenberg, J., "Guidelines for Usage of
                        Interactive Connectivity Establishment (ICE) by
                        non Session Initiation Protocol (SIP)
                        Protocols", Work in Progress, July 2008.

   [RFC4086]            Eastlake, D., Schiller, J., and S. Crocker,
                        "Randomness Requirements for Security", BCP 106,
                        RFC 4086, June 2005.

   [Frag-Harmful]       Kent and Mogul, "Fragmentation Considered
                        Harmful".  Proc. SIGCOMM '87, vol. 17, No. 5,
                        October 1987

   [Port-Numbers]       "IANA Port Numbers Registry",
                        <http://www.iana.org>.

   [Protocol-Numbers]   "IANA Protocol Numbers Registry", 2005,
                        <http://www.iana.org>.