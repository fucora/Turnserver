备忘录
    此文档为网络社区详细说明了一个Internet标准跟踪协议，并希望大家广泛讨论提出建议。为了此协议的标准化，请参考当前版本的“ Internet Official Protocol Standards”。这份备忘录的分发是无限制的。
摘要
    STUN（Session Traversal Utilities for NAT）是一个为其它协议提供NAT穿越的协议。它能被终端设备用于确定NAT分配给的IP地址和端口，它也能被两台终端设备用于测试网络互通性，也能作为一个keep-alive的协议去位置NAT绑定。STUN能用于目前的绝大多数NAT设备，并不需要NAT设备提供特殊的功能。
    STUN协议本身并不是一个NAT穿越的解决方案。当然啦，它是一个NAT穿越解决方案中的载体。相对于RFC3489来说，这是一个巨大的改变。
 1.介绍
   本文申明的STUN协议，提供了一个处理NATS的工具。它提供了一种方式，能让终端设备找到NAT设备分配给自己的公网和私网IP地址和端口。它也提供了一种方式，让终端设备位置NAT绑定。为了延展性，协议能测试两台终端设备之间的网络互通性[MMUSIC-ICE]，或者为两者转发网络数据包[BEHAVE-TURN]。为了保证它的工具属性，文档定义了一个可扩展的数据包格式，定义了在多个网络传输协议上的操作流程，并且提供了两者方式的身份验证。
  STUN旨在被作为NAT穿越方案中的上下文。这些方案被称为STUN标准，每个标准都描述了怎么使用STUN达到NAT穿越的。
   特别的，一个标准指明了STUN消息什么时候发送，包含了哪些属性，使用什么服务器以及使用哪种认证机制。ICE（Interactive Connectivity Establishment）就是一个STUN 标准。SIP拨号时另一个标准。在某些情况下，一个标准需要根据STUN进行拓展。一个STUN拓展可以使用新方法，属性，错误消息的形式。有关STUN用法的更多信息，请参见第14节。 
2.从 RFC 3489演变而来
   STUN 最初定义于 RFC 3489。RFC 3489通常被称为 "经典的STUN", 它代表了解决NAT穿越的一个完整解决方案。在RFC3489中，客户端会发现自己是否在NAT设备后，确定自己的NAT类型，发现自己最外层NAT设备的公网IP地址和端口，然后在协议中一直使用这个IP地址和端口，比如SIP。但是在rfc3489的实战经验发现，这个经典的STUN协议运行的并不足够好。贯穿经典STUN中的IP地址和端口，在对等端上时有时无,它也没有办法判断这种情况，并提供补救措施。此外，经典STUN计算NAT设备类型的算法是由缺陷的,许多的NAT设备不不符合它定义的NAT设备类型。经典STUN也由一个安全性问题，攻击者可以让客户端使用任意的地址，而且根本通过任何加密方式解决这个问题。但现在通过使用更完整的使用STUN的解决方案来缓解这些攻击。 
   由于这些原因，规范库废弃了RFC 3489,并把它作为完整的NAT穿越方案中的工具。ICE是一个完整的NAT穿越方案，它基于[RFC3264]应答式方法。SIP Outbound [SIP-OUTBOUND]是一个完整的SIP信令穿越方案，它使用STUN方式与众不同。 尽管可以使用经典STUN单独作为NAT穿越的解决方案。这个用法在本文中没有描述，并强烈建议不要这么做。这里描述的新STUN协议仅从经典STUN 略微改变。
除UDP之外，新STUN协议现在在TCP上也可以运行。可扩展性以更结构化的方式添加到协议中。magic cookie机制可以让STUN和应用层协议分解开来，它在128位的transaction ID中使用32位来记录magic cookie的值，这样可以保持新旧STUN的兼容性。映射地址使用新的异或格式进行编码。还有其他更微小的变化。请参见第19章的更完整列表。
由于范围的变化，STUN也被从“SimpleTraversal of UDP through NAT”重命名为“Session Traversal Utilities for NAT”。首字母缩略词仍然是STUN，无论如何，这是所有人都记得的。
3.操作概述
本节仅供参考


                               /-----\
                             // STUN  \\
                            |   Server  |
                             \\       //
                               \-----/


                          +--------------+             Public Internet
          ................|     NAT 2    |.......................
                          +--------------+

                          +--------------+             Private NET 2
          ................|     NAT 1    |.......................
                          +--------------+

                              /-----\
                            //  STUN \\
                           |    Client |
                            \\       //               Private NET 1
                              \-----/


                 图1：一种可能的STUN结构

   一种可能的STUN结构如图1所示。有两个实体（称为STUN代理）实现STUN协议。图中的下层代理是STUN客户端，它连接到Private NET 1，这个网络连接通过NAT 1设备连接到Private NET 2，Private NET 2 通过NAT 2设备连接到Public Internet。图中最上层代理是服务，并驻留在公共Internet上。
STUN是一个客户端到服务端的协议，它支持两者类型的事务。一个是请求/响应事务，其中客户端向服务器发送请求，服务器返回响应。第二种是指令事务，其中代理发送指令到服务端或客户端，而且不会产生响应。两种类型的事务都包含了transaction ID，它是随机产生的96位长度的数字。对于请求/响应事务，transaction ID允许客户端将响应与它生成的请求相关联; 对于指示，事务ID用作调试辅助。
所有STUN消息都以固定标头开头，其中包含方法，类和transaction ID。 方法指明了请求或指令的用途。此规范仅定义了一个方法Binding，其他方法会在其他文档中定义。类指明了请求或指令的类型(请求，成功响应，错误响应,指令)。
在固定标题之后会出现零个或多个属性，这些属性是 Type-Length-Value扩展，用于传递请求消息的附加信息。 
   在本文中声明了一个简单的方法叫Binding。Binding方法可以在请求/响应事务或指令中使用。当在请求/响应事务中使用时，Binding方法可用于确定NAT已分配给STUN客户端的特定“binding”。当在请求/响应或指令中使用时，Binding方法也可用于使这些“bindings”保持活动状态。 
   在Binding请求/响应事务中，绑定请求是从STUN客户端发送到STUN服务器。
   当Binding请求到达STUN服务器时，
   它可能已经通过STUN客户端和STUN服务器之间的一个或多个NAT（在图1中有两个这样的NAT）。
   当绑定请求消息通过NAT时，NAT将修改数据包的源传输地址（即源IP地址和源端口），
   因此，服务器接收的请求的源传输地址将是最靠近服务器的NAT创建的公网IP地址和端口，这被叫做反射地址。
   STUN服务器将反射地址复制到STUN Binding响应中的XOR-MAPPED-ADDRESS属性，并将Binding响应发送回STUN客户端。
   当此数据包通过NAT 传回时，NAT将修改IP标头中的目标传输地址，
   但STUN响应正文中的XOR-MAPPED-ADDRESS 属性中的传输地址将保持不变。
   通过这种方式，客户端可以获知最外层NAT相对于STUN服务器分配的反射地址。   
   在一些用法中，STUN必须与其他协议（例如，[ MMUSIC-ICE ]，[ SIP-OUTBOUND ]）复用。
   在这些用法中，必须有一种方法检查数据包并确定它是否是STUN数据包。
   STUN在STUN头中提供了三个字段，其中包含可用于此目的的固定值。如果这还不够，
   则STUN数据包还可以包含FINGERPRINT值，该值可以进一步用于区分数据包。 
   STUN定义了一组可选过程让协议区分使用，称为机制。这些机制包括DNS发现，
   到备用服务器的重定向技术，用于解复用的指纹属性，以及两种身份验证和消息完整性交换。
   身份验证机制的核心是用户名，密码和消息完整性的值。两种身份验证机制包括短期验证和长期验证机制。
   每种用法都指定了该用法允许的机制。 在长期身份验证集中中，客户端和服务器共享预先配置的用户名和密码，
   并执行摘要Challenge 响应交换，其灵感来自（但细节上不同）于为HTTP [ RFC2617 ] 定义的交换。
   在短期凭证机制中，客户端和服务器在STUN交换之前通过一些外带方法交换用户名和密码。
   例如，在ICE使用[ MMUSIC-ICE ]中，两个端点使用带外信令来交换用户名和密码。
   这些用于完整性保护和验证请求和响应。没有使用challenge或nonce。 
4.术语
   在本文档中，关键词"MUST", "MUST NOT", "REQUIRED","SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY","OPTIONAL"将按照BCP 14，RFC 2119 [ RFC2119 ]中的描述进行解释，并指示符合STUN实现的要求级别。
5.定义
   STUN代理：STUN代理是实现STUN 协议的实体。该实体可以是STUN客户端或STUN 服务器。

   STUN客户端：STUN客户端是发送STUN请求并
      接收STUN响应的实体。STUN客户端也可以发送指示。
      在本规范中，术语STUN客户端和客户端是
      同义词。

   STUN服务器：STUN服务器是接收STUN请求并发送STUN响应的实体。STUN服务器也可以发送指示。在本说明书中，术语STUN服务器和服务器是同义词。

   传输地址：IP地址和端口号的组合（例如UDP或TCP端口号）。

自反传输地址：客户端学习的传输地址，用于标识IP网络上的其他主机（通常是STUN服务器）所看到的客户端。当客户端与其他主机之间存在中间NAT时，自反传输地址表示分配给
NAT公共端的客户端的映射地址。在STUN响应中从映射的地址属性（MAPPED-ADDRESS或XOR-MAPPED-ADDRESS）学习自反传输地址。

   映射地址：与反身地址相同的含义。这个词是由于历史原因以及MAPPED-ADDRESS和XOR-MAPPED-ADDRESS属性的命名而保留。

   长期凭据：
      表示客户端和服务器之间共享密钥的用户名和关联密码。
      当订户
      注册服务并持续到订户离开
      服务或明确更改凭证时，通常会向客户端授予长期凭证。

   长期密码：来自长期凭证的密码。

   短期凭证：表示客户端和服务器之间共享密钥的临时用户名和关联密码。短期凭证是在STUN交换之前通过客户端和服务器之间的某种协议机制获得的。短期凭证具有明确的时间范围，其可以基于特定的时间量（例如5分钟）或基于事件（例如SIP对话的终止）。短期凭证的具体范围由应用程序使用定义。

   短期密码：短期凭证的密码组件。
   STUN指令：没有收到响应的STUN消息。
   属性：Type-Length-Value（TLV）对象的STUN术语可以添加到STUN消息中。属性分为两种类型：comprehension-required和comprehension-optional。STUN代理可以安全地忽略他们不理解的理解- 可选属性，但如果消息包含不理解的理解所需属性，则无法成功处理消息。

   RTO：重传TimeOut，定义请求传输与该请求的第一次重传之间的初始时间

6. STUN消息结构



   STUN消息使用二进制的网络格式。 (最重要的字节或八位字节，通常也称为big-endian)。传输顺序在RFC 791 [ RFC0791 ]的附录B中有详细描述。除非另有说明，否则数字常量
以十进制表示（基数为10）。所有STUN消息必须以一个20字节的头开始，后跟零个或多个属性。STUN标头包含STUN消息类型，magic cookie，Transaction ID和消息长度。 
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0|     STUN Message Type     |         Message Length        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Magic Cookie                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                     Transaction ID (96 bits)                  |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   图2：STUN消息头的格式

   每个STUN消息的最重要的2位必须是零。当STUN与同一端口上的其他协议复用时，这可用于区分STUN数据包与其他协议。
   STUN Message Type定义了消息类型(request, successresponse, failure response, or indication) 和消息方法 (主要功能)。 
虽然有四种消息类型，但是可以划分成两种事务类型:
     请求/响应事务（由请求消息和响应消息组成）和指令事务（由单个指示消息组成）。
  响应被分为成功响应和错误响应， 以助于快速处理STUN消息。
 
消息类型字段进一步分解为以下结构：
                        0                 1
                        2  3  4 5 6 7 8 9 0 1 2 3 4 5
                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                       |M |M |M|M|M|C|M|M|M|C|M|M|M|M|
                       |11|10|9|8|7|1|6|5|4|0|3|2|1|0|
                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                      图3：STUN消息类型字段的格式
M11到M0代表了12位编码的METHOD，C1和C0表示了消息类型（0b00是请求，0b01类是
指令，0b10类是成功响应， 0b11 类是错误响应）
该规范定义了一个方法Binding。方法和类是正交的，因此对于每种方法，该方法可以有请求，成功响应，错误响应和指令。定义新方法的扩展必须指出该方法允许哪些类。
例如，Binding请求具有class = 0b00（request）和method = 0b000000000001（Binding）并被编码为前16位为0x0001。Binding响应具有class = 0b10（成功响应）和
 method = 0b000000000001，并且被编码为前16位为0x0101。
   注意：这种不幸的编码是由于在 [ RFC3489 ]中分配的值没有考虑使用位字段编码指示成功和错误。
    Magic cookie字段必须包含网络字节顺序的固定值0x2112A442 。在RFC 3489 [ RFC3489 ]中，此字段是事务ID的一部分; 将Magic cookie放在此位置允许服务器检测客户端是否理解某些属性在本修订规范中添加了。此外，当STUN与同一端口上的其他协议复用时，它有助于区分STUN数据包和其他协议的数据包。
事务ID是96位，用于唯一标识STUN事务。对于请求/响应事务,STUN客户端为请求选择事务ID，并由服务器在响应中附带。对于指令，它由发送指令的代理选择。它主要用于将请求与响应相关联，此外，它也在防止网络攻击上作了一些贡献。服务器还使用事务ID作为密钥，以便在所有客户端中唯一地标识每个事务。。因此，事务ID必须从区间0 .. 2 ** 96-1中统一和随机地选择，并且应该是随机加密的。同一请求的重新发送重用相同的
事务ID，但客户端必须为新事务选择新的事务ID，除非新请求与先前请求在数据上完全相同并从同一传输地址发送到同一IP地址。成功和错误响应必须具有相同的功能事务ID作为其对应的请求。当代理在同一端口上充当STUN服务器和STUN客户端时，代理发送的请求中的事务ID与代理接收的请求中的事务ID 无关。
  消息长度必须去除掉20字节STUN头的消息的大小（以字节为单位）。由于所有STUN属性都
填充为4个字节的倍数，因此该字段的最后2位始终为零。这提供了另一种区分STUN数据包和其他协议数据包的方法。
   在STUN标题的固定部分之后，有零或更多的属性。每个属性都是TLV（Type-Length-Value）编码。编码的细节以及属性本身在第15节中给出。
7.基本协议程序
   本节定义了STUN协议的基本过程。它
   描述了消息的形成方式，消息的发送方式以及消息的
   处理方式。它还定义
   了Binding方法的详细处理。本文档
   中的其他部分描述了在某些
   情况下用法可能选择使用的可选过程。其他文档可以通过
   添加新方法，新属性或新的错误响应代码来定义STUN的其他扩展

7.1.形成请求或指示
在制定请求或指示消息时，代理必须在创建标题时遵循第6节中的规则。此外，消息类必须是“请求”或“指令”（视情况而定），并且该方法必须是Binding或在另一个文档中定义的某种方法。然后，代理会添加方法或用法指定的任何属性。例如，某些用法可能指定代理使用
身份验证方法（第10节）或FINGERPRINT属性（第8节）。如果代理正在发送请求，它应该为请求添加一个SOFTWARE属性。代理可中包含SOFTWARE属性，具体取决于method。STUN的扩展应该讨论软件是否适用于新的适应症。
Binding method不需要身份验证和其它属性，除非另有说明。

通过UDP发送的所有STUN消息应该小于路径MTU。如果路径MTU未知，则消息应该是
 576字节中的较小者和IPv4 [ RFC1122 ]的第一跳MTU和1280字节的IPv6 [ RFC2460 ]。
该值对应于IP数据包的总大小。因此，对于IPv4，实际的STUN消息需要小于548字节（576减去20字节的IP报头，减去8字节的UDP报头，假设没有使用IP选项）STUN不提供处理请求在MTU下但响应大于MTU的情况的能力。没有设想这个限制将成为STUN的问题。MTU限制
应该是一个，而不是必须考虑到STUN本身用于探测MTU特性的情况[ BEHAVE-NAT ]。在外面
在这个或类似的应用程序中，必须遵循MTU约束。

7.2发送请求或指令
  本文档规定了如何通过UDP，TCP或TLS-over-TCP发送STUN消息; 
  将来可能会添加其他传输协议。STUN用法必须指定使用哪种传输协议，
  以及代理如何确定收件人的IP地址和端口。第九节描述了一个usage可能会使用的方法，
  这个方法基于DNS,并且可以确定服务端的ip地址和端口。
  STUN可能会和广播地址一起使用，但是只能使用UDP并且不能使用身份验证。 
  在任何时候，客户端都可能有多个未完成的STUN请求使用相同的STUN服务器。
 （即多个正在处理的事务，使用不同的事务的ID）。
  没有限制新事务的数量（例如ICE指定的链接检查时的限定数量或者STUN运行在TCP上的时候）。
  客户端应该通过RTO将新事务发送到服务器，并且限制自己在同一台服务器上最多只有10个未处理事务。 

7.2.1. 通过UDP发送
   通过UDP运行STUN时，STUN消息可能会遇到丢失的情况。
   STUN 请求/回应的可靠性是通过客户机应用程序本身重新传输请求消息来实现的。
   STUN指令不会重新发送。所以UDP是不可靠的。 

   客户端应该重新发送一个以RTO("Retransmission TimeOut")为时间间隔的请求,
   RTO时间在每次重传后加倍。 
   RTO是往返时间(RTT)的估值, 计算方法如RFC 2988所述[RFC2988]，但是有两个例外。
   首先,RTO的初始值应该是可配置的并且大于500ms（而不是RFC 2988中推荐的3秒）。
   这种“应该”的例外情况是使用其他机制来派生拥塞阈值（比如在ICE中定义的固定速率流），或者当STUN在具有已知网络容量的非internet环境中使用时。
   在使用宽带接入网络时，推荐使用500ms。 
   第二，RTO不应该四舍五入到秒,应保持1ms的精度，与TCP一样，推荐使用Karn算法[KARN87]。
   当应用于STUN时，RTT估值不应该从STUN的重传事务中计算。 

   RTO的值应该在事务完成后被客户端缓存下来，并用作同一服务器的下一个事务的RTO的起始值（基于服务端IP地址判断）。
   这个值应该在十分钟后重新初始化。 
   重传在收到服务端回复前或者达到一定数量前,会一直进行。重传数量应该可配置，默认值是7个。
   如果在最后一个请求之后，持续时间Rm*RTO而没有响应（如果只有最后一个请求成功，则提供足够的时间来获得响应），
   客户端应该认为认为事务失败了。RM应该是可以配置的，并且默认值是16。
   如果存在硬件ICMP错误[RFC1122]， UDP上的STUN事务也会被认为是失败的
   例如，假设RTO为500ms，请求将在0ms、500ms、1500 ms、3500 ms、7500ms、15500 ms和31500 ms时发送。
   如果客户在39500 ms后仍未收到响应，客户将认为事务到已超时。

7.2.2.通过TCP或TLS-over-TCP发送
   对于TCP和TLS-over-TCP，客户机打开到服务器的TCP连接。
   在STUN的一些用法中,STUN作为TCP连接上的唯一协议发送。
   在这种情况下，它可以在没有任何额外的帧或解复用的帮助下发送。

   在某些usages中或者为了拓展，它可以通过TCP连接与其他数据进行多路复用。
   在这种情况下，STUN必须在某种框架协议之上运行，框架协议由usage或extension指定，允许代理提取完整的STUN消息和完整的应用层消息。
 
   在第9节中通过DNS过程发现的已知端口上运行的STUN服务只用于单独的STUN，而不用于与其他数据进行多路复用的STUN。
   因此，在与这些服务器的连接中不使用帧协议。
   当使用额外的帧时，该用法将指定客户机知道如何应用它以及连接到哪个端口。
   例如，在ICE连接检查的情况下，这些信息是通过客户机和服务器之间的额外交互获得的。 

   当STUN独自运行TLS-over-TCP时，必须至少实现TLS_RSA_WITH_AES_128_CBC_SHA密码套件，
   实现还可以支持任何其他加密套件。 
   当接收到TLS证书消息时，客户机应该验证证书并检查证书标识的站点，
   如果证书无效或被撤销，或者没有标识适当的一方，客户端必须不发送STUN消息或以其他方式继续执行STUN事务。
   客户机必须验证服务器的身份，为此，它遵循RFC2818 [RFC2818]第3.1节中定义的识别程序。
   这些过程假定客户机正在取消对一个URI的引用。
   出于使用此规范的目的，客户机将第8.1节中使用的域名或IP地址视为已取消引用的URI的主机部分。
   或者，客户端可以配置一组受信任的域或IP地址;如果接收到标识这些域或IP地址之一的证书，客户机将考虑验证服务器的身份。
     
   当STUN通过TLS-over-TCP连接与其他协议进行多路复用时，强制加密套件和TLS处理过程按照这些协议定义的方式运行。

   TCP上的STUN和TLS-over-TCP上的STUN的可靠性由TCP本身处理，并且在STUN协议级别上不存在重传。
   但是，对于请求/响应事务，如果客户机在发送SYN建立连接后的Ti秒钟内还没有收到响应，则认为事务超时。
   Ti应该是可配置的，默认值应该是39.5秒。选择此值是为了均衡缺省初始RTO的TCP和UDP超时。 
    
   此外，如果客户机无法建立TCP连接，或者TCP连接被重置，或者在接收到响应之前失败，则认为正在进行的任何请求/响应事务都失败了。
 
   客户端可以通过一个TCP(或TLS-over-TCP)连接发送多个事务，并且它可以在接收到前一个请求的响应之前发送另一个请求
   客户端应该保持连接打开，直到:

   o  没有进一步的STUN请求或指令使用该链接,并且

   o  在链接发送请求后不希望收到任何回复(例如映射地址(MAPPED-ADDRESS或XOR-MAPPED-ADDRESS或中继地址[BEHAVE-TURN]), 并且

   o  如果在该端口上复用其他应用程序协议，则使用完该应用程序, 并且

   o  如果将该端口作为对等端端口使用，并远程对等端建立了通信， 这是一些TCP NAT穿越技术(例如[MMUSIC-ICE-TCP])所要求的。

   在服务器端，服务器应该保持连接打开，并让客户机关闭连接，除非服务器确定连接超时(例如，由于客户机断开网络连接)。
   只有当连接保持打开时，客户机的绑定才会在已经打通的NAT设备中时保持有效。
   只有客户端知道需要绑定多长时间。
   当服务端收到的请求还没有回应前，服务端不应该断开TCP链接。 
   服务端不可能为了发送相应，而重新打开客户端和服务端之间的TCP链接。
   服务器应该遵循关于连接管理的最佳实践，以防过载。 

7.3. 收到STUN消息
 
   本节指定STUN消息的处理. 此处指定的处理是针对此规范中定义的STUN消息；
   向后兼容性的附加规则在第12节中定义。这些附加过程是可选的，用法可以选择使用它们。
   首先，定义一组处理操作，但不能定义消息类的。
   接下来是特定于类的处理，在下面的小节中进行描述。
     
   当一个STUN代理接收到一个STUN消息时，它首先检查该消息是否符合第6节的规则。
   它检查前两位是否为0,magic cookie字段是否有正确的值，消息长度是否合理，方法值是否受支持。
   它检查消息类是否允许用于特定的方法。
   如果消息类是“成功响应”或“错误响应”，代理将检查事务ID是否匹配仍在进行中的事务。
   如果正在使用指纹扩展，代理将检查指纹属性是否存在并包含正确的值。
   如果检测到任何错误，消息将被无声地丢弃。
   当STUN与另一个协议进行多路复用时，错误可能表明这不是一个真正的STUN消息;
   在这种情况下，代理应该尝试将消息解析为不同的协议。

   然后，STUN代理执行用法指定的身份验证机制所需的任何检查(参见第10节)

   完成身份验证检查后，STUN代理将检查消息中未知的属性和已知但未预料到的属性。
   未知的可选理解的属性必须被代理忽略。
   代理应该忽略已知但未预料到的属性。
   未知的需要理解的属性导致依赖于消息类的处理，如下所述
   此时，进一步的处理取决于请求的消息类。
  
7.3.1. 处理请求

   如果请求包含一个或多个未知的需要理解的属性，
   服务器将用错误代码420(未知属性)响应一个错误响应，
   并在响应中包含一个未知属性，该属性列出了未知的需要理解的属性
    
   然后，服务器执行方法或特定用法所需的所有检查。如果所有检查都成功，
   服务器将按照下面的描述制定一个成功响应。

   当运行UDP时，服务器接收到的请求可以是事务的第一个请求，也可以是重传。
   服务器必须对重新传输作出响应，以便保留以下属性：

   如果客户机接收到对重传的响应，而不是发送到原始请求的响应，
   则客户机和服务器上的总体状态与仅接收到对原始重传的响应或同时接收到两个响应的情况相同
   （在这种情况下，客户机将使用第一个响应）。 
   
   满足此要求的最简单方法是让服务器记住在UDP上收到的所有事务ID及其在过去40秒内的相应响应。
   但是，这个要求服务器保持状态，并且不适合未经过身份验证的请求。 
   另一种方法是重新处理请求并重新计算响应。 
   后一种技术必须仅应用于幂等的请求（当相同的请求可以安全地重复而不影响系统的整体状态时，请求被认为是幂等的）
   并且对同一请求产生相同的成功响应。 绑定方法被认为是幂等的。 
   请注意，某些罕见的网络事件可能导致自反传输地址值发生更改，
   从而导致不同的映射地址不同成功的回应。
   STUN的扩展必须讨论请求重传对不存储事务状态的服务器的影响

7.3.1.1. 形成成功或错误响应

   在形成响应（成功或错误）时，服务器遵循第6节的规则。
   响应的方法与请求的方法相同，并且消息类是“成功响应”或“错误响应”。
   对于错误响应，服务器必须添加一个ERROR-CODE属性，该属性包含上述处理中指定的错误代码。
   原因短语不是固定的，但应该是适合错误代码的东西。
   对于某些错误，将向消息添加其他属性。
   这些属性在指定错误代码的描述中有详细说明。
   例如，对于错误代码420（未知属性），服务器必须包含UNKNOWN-ATTRIBUTES属性。
   某些身份验证错误也会导致添加属性（参见第10节）.
   扩展可以定义其他错误或附加属性来添加错误情况。

   如果服务器使用身份验证机制对请求进行了身份验证，那么服务器应该向响应添加适当的身份验证属性（参见第10节）。
   服务器还添加特定方法或用法所需的任何属性。此外，服务器应该向消息添加一个SOFTWARE属性。
   对于绑定方法，不需要进行额外的检查，除非用法另有规定。

   在形成成功响应时，服务器向响应添加一个xor-mapped-address属性，其中该属性的内容是请求消息的源传输地址。
   对于UDP，这是请求消息的源IP地址和源UDP端口。
   对于TCP和TLS-over-TCP，这是服务器看到的TCP连接的源IP地址和源TCP端口。

7.3.1.2. 发送成功或错误响应
   响应（成功或错误）和请求使用相同的传输方式发送。
   如果通过UDP接收到请求，则响应的目标IP地址和端口为接收到的请求消息的源IP地址和端口，
   响应的源IP地址和端口等于接收到的请求消息的目标IP地址和端口。
   如果通过TCP或TLS-over-TCP接收到请求，则响应将通过与接收请求相同的TCP连接发送回。 

7.3.2. 处理指令
   如果指令含有未知的需要理解的属性，则抛弃指令。 
   然后，代理将执行任何附加检查，以确保该方法或特定用法需要。
   如果所有检查都成功，代理将处理指令。不对指令返回消息。 

   对于绑定方法，不需要进行额外的检查或处理，除非用法另有规定。代理仅仅收到消息就刷新了中间NAT中的“绑定”。
   由于指示不会通过UDP重新传输（与请求不同），因此不需要在发送代理处处理指示的重新传输。

7.3.3.  处理成功响应
 
   如果成功响应包含未知的需要理解的属性，则将丢弃响应并认为事务已失败。
 
   之后，客户机执行该方法或特定用法所需的任何附加检查。如果所有检查都成功，则客户端将处理成功响应。
   对于绑定方法，客户机检查响应中是否存在xor-mapped-address属性。
   客户端检查指定的地址族。如果它是不受支持的地址族，则应忽略该属性。

   如果它是意外但受支持的地址系列（例如，绑定事务是通过IPv4发送的，但指定的地址是IPv6），
   则客户端可以接受并使用该值。 

7.3.4.  处理错误响应
   如果错误响应包含不知道的需要理解的属性，或者如果错误响应不包含RROR-CODE属性，那么交易就被简单地认为失败了。
   然后，客户机执行由身份验证机制指定的所有处理（参见第10节）。这可能导致新的事务尝试。

   此时的处理取决于错误代码、方法和用法；以下是默认规则：
   
   o  如果错误代码是300到399，除非使用ALTERNATE-SERVER扩展，否则客户端应将事务视为失败。见第11节。

   o  如果错误代码是400到499，则客户端声明事务失败；如果是420（未知属性），则响应应包含一个UNKNOWN-ATTRIBUTES属性，该属性提供附加信息。.

   o  如果错误代码是500到599，客户机可以重新发送请求；这样做的客户机必须限制他们这样做的次数。

   任何其他错误代码都会导致客户端认为事务失败。

8.  指纹机制
 
   本节描述了一种可选的stun机制，当两个协议在同一传输地址上多路复用时，
   该机制有助于区分stun消息和其他协议的包。
   这个机制是可选的，STUN用法必须描述是否以及何时使用。
   指纹机制与RFC3489不兼容，并且不能在需要这种兼容性的环境中使用。.

   在某些应用中，stun消息在与其他协议（如实时传输协议（RTP））相同的传输地址上进行多路复用。
   为了应用第7节中描述的处理，必须首先将stun消息与应用程序包分开。
    
   第6节描述了stun头中可以用于此目的的三个固定字段。但是，在某些情况下，这三个固定字段可能不够 
   使用指纹扩展时，代理在发送给另一个代理的消息中包含指纹属性。 
   第15.5节描述了该属性的位置和值。
   当代理接收到它认为是STUN消息的内容时，除了其他基本检查外，代理还检查消息是否包含指纹属性以及该属性是否包含正确的值。
   第7.3节描述了在特技信息的整体处理过程中，何时执行指纹检查。
   此附加检查有助于代理检测其他协议的消息，这些消息可能在其他情况下看起来像是STUN消息。

9.  服务器的DNS发现
 
   本节描述了一个可选的stun过程，该过程允许客户端使用DNS来确定服务器的IP地址和端口。
   STUN用法必须描述是否和何时使用此扩展。要使用此过程，客户机必须知道服务器的域名和服务名称；
    
   用法还必须描述客户机如何获得这些信息。为防止域名丢失或因法律或其他原因需要更改，不建议将服务器的域名硬编码在软件里。
   当客户端希望在公共Internet中找到接受绑定请求/响应事务的stun服务器时，srv服务名称为“stun”。
   当它希望找到使用TLS接受绑定请求/响应事务的stun服务器时，srv服务名称为“stuns”。
   stun用法可以定义其他DNS SRV服务名称。
   使用[rfc2782]中指定的srv过程将域名解析为传输地址。
   DNS SRV服务名称是是此过程的所说的服务名称。
   DNS发现中的传输协议就是客户端将运行stun的传输协议：udp和udp，tcp和tcp。
   注意，此时只有“tcp”被定义为“stuns”。 

   按照RFC2782的过程确定要联系的服务器。
   RFC2782详细说明了如何对一组SRV记录进行排序和尝试。
   但是，RFC2782只声明客户机应该“尝试连接到（协议、地址、服务）”，而不提供在发生故障时发生的任何细节。
   当遵循这些过程时，如果STUN事务超时而没有收到响应，则客户端应该重新尝试请求到RFC 2782定义的有序命令中的下一个服务器。
   这种重试仅对请求/响应传输是可能的，因为指令事务不产生响应或超时.

   对于TCP和UDP，STUN请求的默认端口是3478。
   STUN服务器的管理员应该在他们的SRV记录中使用此端口来获取UDP和TCP。
   在所有情况下，DNS中的端口必须反映服务器正在侦听的端口。
   STUN over TLS的默认端口是5349.如果服务器软件支持确定初始消息是TLS还是STUN消息，
   则服务器可以在与STUN相同的端口上通过TLS运行STUN over STLS。

   如果未找到SRV记录，则客户端将执行域名的A或AAAA记录查找。 
   结果将是一个IP地址列表，每个IP地址都可以使用UDP或TCP在默认端口联系，
   而与STUN使用无关。 对于需要TLS的用法，
   客户端使用默认的STUN over TLS端口连接到其中一个IP地址。

10.  身份验证和消息完整性机制


   本节定义了STUN的两种机制，客户端和服务器可以使用它们来提供身份验证和消息完整性;
   这两种机制被称为短期凭证机制和长期凭证机制. 
   这两种机制是可选的，每种用法必须指定是否以及何时使用这些机制。
   因此，客户端和服务器都将根据不同的用法遵循不同的机制 （如果有的话）
   例如，支持ICE的公共Internet上的STUN服务器将不进行身份验证，
   而支持连接性检查的代理中的STUN服务器功能将使用短期凭据。
   第3节给出了这两种机制的概述。
   每种机制都指定使用该机制所需的额外处理，从而扩展了第7节中指定的处理。
   额外处理发生在三个不同的地方：
   在形成消息时，
   在执行基本检查后立即收到消息时，
   并且在进行错误响应的详细处理时。

10.1. 短期认证机制
 
   短期凭证机制假定，在STUN事务之前，客户端和服务器已经使用一些其他协议以用户名和密码的形式交换凭证。
   此凭证有时间限制。凭证有效时间由用法定义。
   例如，在ICE用法[MMUSIC-ICE]中，
   两个端点使用外带信令来同意用户名和密码，并且此用户名和密码在媒体会话过程中一直有效。 
   此凭证用于在每个请求和许多响应中形成消息完整性检查。
   长期身份验证机制中挑战和回应，而短期验证是没有的。
    因此，此凭证的时间限制性质决定了请求不能重复。 

10.1.1.  形成请求或指令
          对于请求或指示消息，代理必须在消息中包含USERNAME和MESSAGE-INTEGRITY属性。 
		  MESSAGE-INTEGRITY属性的HMAC按照第15.4节中的描述进行计算。 
		  请注意，密码永远不会包含在请求或指示中。

10.1.2. 收到请求或指示 
    代理完成消息的基本处理后，代理按指定的顺序执行下面列出的检查:

   o  如果消息不包含MESSAGE-INTEGRITY和USERNAME属性:

      *  如果消息是请求，服务器必须拒绝带有错误响应的请求。 此响应必须使用错误代码400（错误请求）.

      *  如果消息是指示，则代理必须以静默方式丢弃该指示.

   o  如果USERNAME不包含当前在服务器中有效的用户名值:

      *  如果消息是请求，服务器必须拒绝带有错误响应的请求。 此响应必须使用错误代码401（未授权）.

      *  如果消息是指示，则代理必须以静默方式丢弃该指示.

   o  服务端使用与用户名关联的密码，计算消息完整性的值，如第15.4节中所述。 
      如果结果值与MESSAGE-INTEGRITY属性的内容不匹配: 

      *  如果消息是请求，服务器必须拒绝带有错误响应的请求。 此响应必须使用错误代码401（未授权）。

      *  如果消息是指示，则代理必须以静默方式丢弃该指示。

   如果这些检查通过，则代理继续处理请求或指示。 
   服务器生成的任何响应都必须包含MESSAGE-INTEGRITY属性，
   使用密码计算后的值和MESSAGE-INTEGRITY属性对比，进行身份验证。 响应绝不能包含USERNAME属性。 
   如果任何检查失败，服务器响应不得包含MESSAGE-INTEGRITY或USERNAME属性。 
   这是因为，在这些故障情况下，服务器无法计算MESSAGE-INTEGRITY。

10.1.3.  客户端收到回应
 
   客户端在响应中查找MESSAGE-INTEGRITY属性。
   如果存在，客户端使用与请求相同的密码计算第15.4节中定义的响应的消息完整性。
   如果结果值与MESSAGE-INTEGRITY属性的内容匹配，则认为响应已通过身份验证。
   如果值不匹配，或者如果MESSAGE-INTEGRITY不存在，则必须丢弃响应，就好像它从未收到过一样。 
   这意味着如果适用，重新传输将继续。 

10.2.  长期认证机制

    长期凭证机制依赖于长期凭证，
    以客户端和服务器之间共享的用户名和密码的形式。
    凭证被认为是长期的，因为假设它是为用户供应的，并且在用户不再是系统的订户或者被更改之前保持有效。
	这基本上是给用户的传统“登录”用户名和密码。

	由于这些用户名和密码预计会在较长时间内有效，以消化挑战的形式提供重播预防。
	在此机制中，客户端最初发送请求，而不提供任何凭据或任何完整性检查。
    服务器拒绝此请求，为用户提供realm（用于指导用户或代理选择用户名和密码）和nonce。
	nonce提供重播保护。
	它是一个cookie，由服务器选择，并以这样的方式编码，以指示其有效的持续时间或客户端身份。
	客户端重试请求，这次包括其用户名和 领域，并回应服务器提供的随机数。
	客户端还包括消息完整性，它在整个请求中提供HMAC，包括nonce。
	服务器验证nonce并检查消息完整性。 如果匹配，则对请求进行身份验证。 
	如果nonce不再有效，则认为它是“陈旧的”，服务器拒绝该请求，提供新的nonce。
	在对同一服务器的后续请求中，客户端重用其先前使用的nonce，username，realm和password。
    通过这种方式，后续请求不会被拒绝，直到服务器的nonce变为无效，在这种情况下拒绝为客户端提供新的nonce.

    请注意，长期凭证机制不能用于保护指示，因为指示不能受到质疑。 
    使用指示的用法必须使用短期凭证或省略其身份验证和消息完整性。

	由于长期凭证机制容易受到离线字典攻击，因此部署应该使用难以猜测的密码。
	如果凭证未由用户输入，而是在设备配置期间放置在客户端设备上，则密码应该具有至少128位的随机性。
     在用户输入凭证的情况下，他们应该遵循密码结构的最佳实践。

10.2.1.  客户端形成请求

     形成请求时有两种情况。 
     在第一种情况下，这是从客户端到服务器的第一个请求（由其IP地址和端口标识）。
     在第二种情况下，一旦先前的请求/响应事务成功完成，客户端就提交后续请求。 
   
     由于401或438错误响应而产生的请求在第10.2.3节中有所涉及，
     并且不被视为“后续请求”，因此不使用第10.2.1.2节中描述的规则。

10.2.1.1.  第一次请求

 如果客户端尚未与服务器完成成功的请求/响应事务
（由主机名标识，如果使用第9节的DNS过程，否则使用IP地址），
 它应该省略USERNAME，MESSAGE-INTEGRITY，REALM和NONCE属性。 
 换句话说，第一个请求被发送，就好像没有应用身份验证或消息完整性一样。
    
10.2.1.2.  后续请求
 
  成功完成请求/响应事务后，服务器将向客户端显示realm和nonce，客户端选择用于进行身份验证的用户名和密码。
  客户端应该缓存用户名，密码，领域和随机数以便与服务器进行后续通信。
  当客户端发送后续请求时，它应该包含带有这些缓存值的USERNAME，REALM和NONCE属性。
  它应该包含一个MESSAGE-INTEGRITY属性，使用缓存的密码按照第15.4节中的描述进行计算。

10.2.2.  服务端收到请求
 
   服务器完成对请求的基本处理后，它会按照指定的顺序执行下面列出的检查：

   o  如果消息不包含MESSAGE-INTEGRITY属性，
      则服务器必须生成错误响应，错误代码为401（未授权）。 
      该响应必须包含REALM值。 建议REALM值是STUN服务器提供者的域名。
      响应必须包括服务器选择的NONCE。 
      响应不应该包含USERNAME或MESSAGE-INTEGRITY属性。

   o  如果消息包含MESSAGE-INTEGRITY属性，
      但缺少USERNAME，REALM或NONCE属性，则服务器必须生成错误响应，错误代码为400（错误请求）。 
      此响应不应包含USERNAME，NONCE，REALM或MESSAGE-INTEGRITY属性。

   o  如果NONCE不再有效，服务器必须生成错误响应，错误代码为438（Stale Nonce）。 
      此响应必须包含NONCE和REALM属性，并且不应包含USERNAME或MESSAGE-INTEGRITY属性。 
      服务器可以使nonce无效，以提供额外的安全性。 
      有关指南，请参见[RFC2617]的第4.3节。

   o  如果USERNAME属性中的用户名无效，则服务器必须生成错误响应，
      错误代码为401（未授权）。 
      该响应必须包含REALM值。 建议REALM值是STUN服务器提供者的域名。 
      响应必须包括服务器选择的NONCE。 
      响应不应该包含USERNAME或MESSAGE-INTEGRITY属性。
 
   o  使用与USERNAME属性中的用户名关联的密码，
      计算消息完整性的值，如第15.4节中所述。 
	  如果结果值与MESSAGE-INTEGRITY属性的内容不匹配，
	  则服务器必须拒绝带有错误响应的请求。 
	  此响应必须使用错误代码401（未授权）。 
	  它必须包含REALM和NONCE属性，并且不应包含USERNAME或MESSAGE- INTEGRITY属性。
	   
10.2.3. 客户端收到回复
    
	如果响应是错误响应，错误代码为401（未授权），则客户端应该使用新事务重试该请求。
	此请求必须包含USERNAME，由客户端确定为错误响应中REALM的相应用户名。
	请求必须包含从错误响应中复制的REALM。
    请求必须包含从错误响应中复制的NONCE。 
	请求必须包含MESSAGE-INTEGRITY属性，该属性使用与USERNAME属性中的用户名关联的密码计算。  		 
	如果客户端没有更改上一次尝试中的USERNAME或REALM或其关联密码，则不得执行此重试。

    如果响应是错误响应，错误代码为438（Stale Nonce），
    则客户端必须使用438（Stale Nonce）响应中提供的新NONCE重试该请求。
    此重试还必须包括USERNAME，REALM和MESSAGE-INTEGRITY。

	客户端在响应中查找MESSAGE-INTEGRITY属性（成功或失败）。

	如果存在，客户端使用与请求相同的密码计算第15.4节中定义的响应的消息完整性。
    如果结果值与MESSAGE-INTEGRITY属性的内容匹配，则认为响应已通过身份验证。 
	如果值不匹配，或者如果MESSAGE-INTEGRITY不存在，
	则必须丢弃响应，就好像它从未收到过一样。
	这意味着如果适用，重新传输将继续。
	 
11. 备用服务器机制
 
   本节介绍STUN中允许服务器将客户端重定向到另一台服务器的机制。 
   此扩展名是可选的，用法必须定义是否以及何时使用此扩展名。

   使用此扩展的服务器通过回复带有错误代码为300
   （尝试替代）的错误响应消息的请求消息，
   将客户端重定向到另一台服务器。
   服务器必须在错误响应中包含ALTERNATE-SERVER属性。 
   可以验证错误响应消息; 但是，ALTERNATE-SERVER有一些用例，其中响应的验证是不可能或不可行的。

   使用此扩展的客户端处理300（Try Alternate）错误代码，如下所示。 
   客户端在错误响应中查找ALTERNATE-SERVER属性。 
   如果找到一个，则客户端将当前事务视为失败，
   并使用与先前请求相同的传输协议，使用该属性中指定的服务器重新尝试该请求。
   该请求如果经过身份验证，则必须使用客户端在执行重定向的服务器请求中使用的相同凭据。
   如果客户端已被重定向到最近五分钟内已尝试过此请求的服务器，则必须忽略重定向并认为事务已失败。 
   这可以防止在重定向循环的情况下服务器之间的无限尝试。 

12.  向后兼容RFC 3489


   本节定义了允许与RFC 3489 [RFC3489]中定义的原始协议进行一定程度的向后兼容的过程。 
   此机制是可选的，仅在新客户端可以连接到旧服务器的情况下使用，
   反之亦然。 用法必须定义是否以及何时使用此过程。
   在RFC 3489种: 
   o  UDP是唯一受支持的传输。

   o  现在是magic cookie字段的字段是事务ID字段的一部分，事务ID是128位长。
	   
   o  XOR-MAPPED-ADDRESS属性不存在，Binding方法使用MAPPED-ADDRESS属性。

   o  有三个要求理解的属性，已从此规范中删除的响应地址，更改请求和已更改地址。

      *  CHANGE-REQUEST和CHANGED-ADDRESS现在是NAT行为发现用法[BEHAVE-NAT]的一部分，另一个不推荐使用。

12.1.  客户端处理的更改
 
   想要与[RFC3489]服务器互操作的客户端应该发送使用Binding方法的请求消息，
   不包含任何属性，并使用UDP作为服务器的传输协议。 
   如果成功，从服务器收到的成功响应将包含MAPPED-ADDRESS属性，
   而不是XOR-MAPPED-ADDRESS属性。 
   寻求与旧服务器互操作的客户端必须准备好接收。 
   此外，客户端必须忽略可能出现在响应中的任何保留理解所需的属性。 
   在第18.2节中的保留属性中，0x0002,0x0004,0x0005和0x000B可能出现在来自符合RFC 3489的服务器的绑定响应中。
   除了此更改之外，响应的处理与上述过程相同。

12.2.  服务器处理的更改
   
   STUN服务器可以通过magic cookie字段中缺少正确的值来检测何时从
   RFC 3489 [RFC3489]客户端发送给定的绑定请求消息。 
   当服务器检测到RFC 3489客户端时，
   它应该将Binding请求中magic cookie字段中看到的值
   复制到Binding响应消息中的magic cookie字段，
   并插入MAPPED-ADDRESS属性而不是XOR-MAPPED-ADDRESS 属性。
    
   在极少数情况下，客户可能包括RESPONSE-ADDRESS或CHANGE-REQUEST属性。 
   在这些情况下，服务器会将这些视为未知的理解所需属性，并回复错误响应。
   由于不再支持使用这些属性的机制，因此这种行为是可以接受的。

   RFC 3489版本的STUN缺少magic cookie和FINGERPRINT属性，
   允许在与其他协议复用时正确识别STUN消息的概率非常高。
   因此，向后兼容RFC 3489的STUN实现不应该在STUN与其他协议复用的情况下使用。
   但是，这不应该是一个问题，因为RFC 3489中没有这种多路复用。

13.  基本服务器行为
 
   本节定义基本的独立STUN服务器的行为。
   基本STUN服务器通过接收和回复STUN Binding请求为客户端提供服务器自反传输地址。

   STUN服务器必须支持Binding方法。 它不应该使用短期或长期的凭证机制。
   
   这是因为验证请求所涉及的工作不仅仅是简单处理它的工作。
   出于同样的原因，它不应该使用ALTERNATE-SERVER机制。
   它必须支持UDP和TCP。 它可以通过TCP / TLS支持STUN; 但是，TLS在这种基本操作模式下提供的安全性最小。
   它可以使用FINGERPRINT机制，但绝不需要它。 由于独立服务器只运行STUN，因此FINGERPRINT没有任何好处。
   要求它会破坏与RFC 3489的兼容性，并且在独立服务器中需要这种兼容性。
   独立的STUN服务器应该支持向后兼容[RFC3489]客户端，如第12节所述。
   
   建议STUN服务器的管理员为这些服务器提供DNS条目，如第9节所述。

   基本的STUN服务器本身不是NAT穿透的解决方案。 
   但是，它可以通过STUN使用作为解决方案的一部分。 
   这将在第14节中进一步讨论。

14.  STUN用法

   STUN本身不是NAT遍历问题的解决方案。 
   相反，STUN定义了一个可以在更大的解决方案中使用的工具。 
   术语“STUN用法”用于任何使用STUN作为组件的解决方案。

   在撰写本文时，定义了三种STUN用法：交互式连接建立（ICE）[MMUSIC-ICE]，
   SIP [SIP-OUTBOUND]的客户端发起的连接和NAT行为发现[BEHAVE-NAT]。 
   其他STUN用法可能在将来定义。

   STUN用法定义了如何实际使用STUN  - 
   何时发送请求，如何处理响应，以及在此定义（
   或在STUN的扩展中）定义的可选过程。 
   用法还将定义：
    
   o  使用哪种STUN方法。

   o  使用什么身份验证和消息完整性机制。

   o  关于完整性机制的手动与自动密钥派生的考虑因素，如[RFC4107]中所述。

   o  使用什么机制来区分STUN消息和其他消息。 当STUN通过TCP运行时，可能需要一个框架机制。

   o  STUN客户端如何确定STUN服务器的IP地址和端口。

   o  是否需要向后兼容RFC 3489。

   o  这里定义了哪些可选属性（例如FINGERPRINT和ALTERNATE-SERVER）或其他扩展名是必需的。

   此外，任何STUN用法都必须考虑在该用法中使用STUN的安全隐患。 
   已知许多针对STUN的攻击（请参阅本文档中的“安全注意事项”部分），
   任何使用必须考虑如何阻止或减轻这些攻击。

   最后，用法必须考虑其使用STUN是否是NAT遍历的单边自解地方法的示例，
   如果是，请解决RFC 3424 [RFC3424]中提出的问题。

15.  STUN属性

   STUN头之后是零个或多个属性。
   每个属性必须是TLV编码的，具有16位类型，16位长度和值。
   每个STUN属性必须以32位边界结束。 
   如上所述，属性中的所有字段首先发送最高有效位。

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Type                  |            Length             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Value (variable)                ....
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                             图4：STUN属性的格式
 
   长度字段中的值必须包含属性的Value部分的长度，在填充之前，以字节为单位。 
   由于STUN在32位边界上对齐属性，因此内容不是4个字节的倍数的属性将填充1,2或3个字节的填充，
   以使其值包含4个字节的倍数。 填充位被忽略，并且可以是任何值。

   任何属性类型都可能在STUN消息中出现多次。
   除非另有说明，否则出现的顺序是重要的：
   只有第一次出现需要由接收者处理，并且接收者可以忽略任何重复。

   为了允许将来修订此规范以在需要时添加新属性，
   属性空间将分为两个范围。 类型值介于0x0000和0x7FFF之间的属性是需要理解的属性，
   除非它理解该属性否则STUN代理无法成功处理消息。 
   类型值介于0x8000和0xFFFF之间的属性是可选理解的属性，
   这意味着如果STUN代理不理解这些属性， 则可以忽略这些属性。 

   STAN属性类型集由IANA维护。 本规范定义的初始集可在第18.2节中找到。

   本节的其余部分描述了本规范中定义的各种属性的格式。

15.1.  MAPPED-ADDRESS


   MAPPED-ADDRESS属性指示客户端的自反传输地址。 
   它由一个8位地址族和一个16位端口组成，
   后跟一个表示IP地址的固定长度值。 
   如果地址族是IPv4，则地址必须是32位。 
   如果地址族是IPv6，则地址必须是128位。 
   所有字段必须按网络字节顺序排列。
    
   MAPPED-ADDRESS属性的格式为:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 0 0 0 0|    Family     |           Port                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                 Address (32 bits or 128 bits)                 |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      图5：MAPPED-ADDRESS属性的格式

   地址族可以采用以下值：
   0x01:IPv4
   0x02:IPv6

   MAPPED-ADDRESS的前8位必须设置为0，接收器必须忽略它。 这些位用于在自然32位边界上对齐参数。

   此属性仅供服务器使用，以实现与RFC 3489 [RFC3489]客户端的向后兼容性。

15.2.  XOR-MAPPED-ADDRESS
 
   XOR-MAPPED-ADDRESS属性与MAPPED-ADDRESS属性相同，只是反身传输地址通过XOR函数进行模糊处理。 
   XOR-MAPPED-ADDRESS的格式是:

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |x x x x x x x x|    Family     |         X-Port                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                X-Address (Variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    图6：XOR-MAPPED-ADDRESS属性的格式

  Family表示IP地址族，其编码方式与MAPPED-ADDRESS中的Family相同。
 
  X-Port的计算方法是将映射端口按主机字节顺序排序，
  将其与magic cookie的最高16位进行异或，然后将结果转换为网络字节顺序。

  如果IP地址族是IPv4，则通过以主机字节顺序获取映射的IP地址，
  使用magic cookie对其进行异或，并将结果转换为网络字节顺序来计算X-Address。

  如果IP地址族是IPv6，则通过以主机字节顺序获取映射的IP地址来计算X-Address，
  通过magic cookie和96位事务ID的串联对其进行异或，并将结果转换为网络字节顺序。

   编码和处理属性值的前8位的规则，处理多次出现的属性的规则以及处理地址族的规则与MAPPED-ADDRESS的规则相同。

   注意：XOR-MAPPED-ADDRESS和MAPPED-ADDRESS仅在传输地址的编码方面有所不同。 
   前者通过使用magic cookie排他或编码来对传输地址进行编码。
   后者直接以二进制编码。 RFC 3489最初只指定了MAPPED-ADDRESS。
   但是，部署经验发现，一些NAT重写了包含NAT的公共IP地址的32位二进制有效负载，
   例如STUN的MAPPED-ADDRESS属性，这意味着误导了提供通用ALG功能的尝试。 
   这种行为会干扰STUN的操作，并导致STUN的消息完整性检查失败。 

15.3.  USERNAME
 
   USERNAME属性用于消息完整性。 它标识消息完整性检查中使用的用户名和密码组合。

   USERNAME的值是可变长度值。 它必须包含一个小于513字节的UTF-8 
   [RFC3629]编码序列，并且必须使用SASLprep [RFC4013]进行处理。

15.4.  MESSAGE-INTEGRITY
 
   MESSAGE-INTEGRITY属性包含STUN消息的HMAC-SHA1 [RFC2104]。
   MESSAGE-INTEGRITY属性可以存在于任何STUN消息类型中。
   由于它使用SHA1哈希，因此HMAC将为20个字节。

   用作HMAC输入的文本是STUN消息，包括标题，
   直到并包括MESSAGE-INTEGRITY属性之前的属性。
   除了在MESSAGE-INTEGRITY之后出现的FINGERPRINT属性之外，
   代理必须忽略MESSAGE-INTEGRITY之后的所有其他属性。
    
   HMAC的关键取决于是否使用长期或短期凭证。 对于长期凭证，密钥是16个字节:

            key = MD5(username ":" realm ":" SASLprep(password))
   也就是说，通过获取连接以下五个字段的结果的MD5哈希来形成16字节密钥：
   (1) 用户名，删除了任何引号和尾随空值，取自USERNAME属性（已经应用了SASLprep）；
   (2) 一个冒号 (3) realm，删除任何引号和尾随空值;
   (4) 一个冒号; (5) 密码，删除任何尾随空值并在使用SASLprep处理之后。  
    例如，如果用户名是'user'，则领域是'realm'，密码是'pass'，
    那么16字节的HMAC密钥将是对字符串'user：realm：pass'执行MD5哈希的结果，
    结果哈希值为0x8493fbc53ba582fb4c044c456bdc40eb。

    对于短期凭证： 
                     key = SASLprep(password)

   其中MD5在RFC 1321 [RFC1321]中定义，SASLprep（）在RFC 4013 [RFC4013]中定义。

   当与长期凭证一起使用时，密钥的结构便于在也使用SIP的系统中进行部署。
   通常，使用SIP的摘要认证机制的SIP系统实际上不会将密码存储在数据库中。
   相反，它们存储一个名为H（A1）的值，它等于上面定义的键。

   根据上述规则，用于构造MESSAGE-INTEGRITY的哈希包括来自STUN消息头的长度字段。
   在执行散列之前，必须将MESSAGE-INTEGRITY属性插入到消息中（具有虚拟内容）。
   然后必须将长度设置为指向消息的长度，包括MESSAGE-INTEGRITY属性本身，但不包括其后的任何属性。
   一旦执行了计算，就得到了它的值就可以填写MESSAGE-INTEGRITY属性，
   并且可以将STUN头中的长度值设置为其正确的值 - 整个消息的长度。
   类似地，在验证MESSAGE-INTEGRITY时，
   应在计算HMAC之前调整长度字段以指向MESSAGE-INTEGRITY属性的结尾。  
   当MESSAGE-INTEGRITY之后出现诸如FINGERPRINT之类的属性时，这种调整是必要的。
    
15.5.  FINGERPRINT


   The FINGERPRINT attribute MAY be present in all STUN messages.  The
   value of the attribute is computed as the CRC-32 of the STUN message
   up to (but excluding) the FINGERPRINT attribute itself, XOR'ed with
   the 32-bit value 0x5354554e (the XOR helps in cases where an
   application packet is also using CRC-32 in it).  The 32-bit CRC is
   the one defined in ITU V.42 [ITU.V42.2002], which has a generator
   polynomial of x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1.
   When present, the FINGERPRINT attribute MUST be the last attribute in
   the message, and thus will appear after MESSAGE-INTEGRITY.

   The FINGERPRINT attribute can aid in distinguishing STUN packets from
   packets of other protocols.  See Section 8.

   As with MESSAGE-INTEGRITY, the CRC used in the FINGERPRINT attribute
   covers the length field from the STUN message header.  Therefore,
   this value must be correct and include the CRC attribute as part of
   the message length, prior to computation of the CRC.  When using the
   FINGERPRINT attribute in a message, the attribute is first placed
   into the message with a dummy value, then the CRC is computed, and
   then the value of the attribute is updated.  If the MESSAGE-INTEGRITY
   attribute is also present, then it must be present with the correct
   message-integrity value before the CRC is computed, since the CRC is
   done over the value of the MESSAGE-INTEGRITY attribute as well.

15.6.  ERROR-CODE
    error-code属性用于错误响应消息。
    它包含一个范围为300到699的mumeric错误代码值，
    加上UTF-8 [RFC3629]编码的文本原因短语，
    并且其代码赋值和语义与SIP [RFC3261]和HTTP " RFC2616]一致。
    原因短语用于用户消费，
    可以是任何适合错误代码的内容。
	定义错误代码的推荐原因短语包含在错误代码的IANA注册表中。
    原因短语必须是UTF-8 [RFC3629]编码的小于128个字符(最长可达763字节)的等式

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Reserved, should be 0         |Class|     Number    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Reason Phrase (variable)                                ..
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 7: ERROR-CODE Attribute
 
   为了便于处理，错误代码的类（百位数）与其余代码分开编码，如图7所示。
  
   Reserved应该为0，并用于32位边界的对齐。 接收器必须忽略这些位。
   Class表示错误代码的百位数，值必须介于3和6之间。Number表示模数为100的错误代码，其值必须介于0和99之间。
    
   以下错误代码及其推荐原因短语，定义：

   300  Try Alternate: The client should contact an alternate server for
        this request.  This error response MUST only be sent if the
        request included a USERNAME attribute and a valid MESSAGE-
        INTEGRITY attribute; otherwise, it MUST NOT be sent and error
        code 400 (Bad Request) is suggested.  This error response MUST
        be protected with the MESSAGE-INTEGRITY attribute, and receivers
        MUST validate the MESSAGE-INTEGRITY of this response before
        redirecting themselves to an alternate server.

             Note: Failure to generate and validate message integrity
             for a 300 response allows an on-path attacker to falsify a
             300 response thus causing subsequent STUN messages to be
             sent to a victim.

   400  Bad Request: The request was malformed.  The client SHOULD NOT
        retry the request without modification from the previous
        attempt.  The server may not be able to generate a valid
        MESSAGE-INTEGRITY for this error, so the client MUST NOT expect
        a valid MESSAGE-INTEGRITY attribute on this response.

   401  Unauthorized: The request did not contain the correct
        credentials to proceed.  The client should retry the request
        with proper credentials.

   420  Unknown Attribute: The server received a STUN packet containing
        a comprehension-required attribute that it did not understand.
        The server MUST put this unknown attribute in the UNKNOWN-
        ATTRIBUTE attribute of its error response.

   438  Stale Nonce: The NONCE used by the client was no longer valid.
        The client should retry, using the NONCE provided in the
        response.

   500  Server Error: The server has suffered a temporary error.  The
        client should try again.
		 
15.7.  REALM

    
	REALM属性可能出现在请求和响应中。 它包含符合“realm-value”语法的文本，
	如RFC 3261 [RFC3261]中所述，但没有双引号及其周围的空格。
	也就是说，它是一个不带引号的域值（因此是qdtext或引用对的序列）。 
	它必须是一个小于128个字符的UTF-8 [RFC3629]编码序列（可以长达763个字节），
	并且必须使用SASLprep [RFC4013]进行处理。 

   请求中存在REALM属性表示正在使用长期凭据进行身份验证。 
   某些错误响应中的存在表示服务器希望客户端使用长期凭证进行身份验证。

15.8.  NONCE

   NONCE属性可以存在于请求和响应中。 
   它包含一系列qdtext或quoted-pair，
   它们在RFC 3261 [RFC3261]中定义。 
   请注意，这意味着NONCE属性不包含实际引用字符。 
   有关在服务器中选择nonce值的指导，请参阅RFC 2617 [RFC2617]，第4.3节。
   它必须少于128个字符（可以长达763个字节）。

15.9.  UNKNOWN-ATTRIBUTES
 
      当ERROR-CODE属性中的响应代码为420时，UNKNOWN-ATTRIBUTES属性仅出现在错误响应中。
	  该属性包含16位值的列表，每个值表示服务器无法理解的属性类型。

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Attribute 1 Type           |     Attribute 2 Type        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Attribute 3 Type           |     Attribute 4 Type    ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	   
                图8：UNKNOWN-ATTRIBUTES属性的格式
 
     注意：在[RFC3489]中，通过复制最后一个属性将此字段填充为32。
	 在此版本的规范中，使用了属性的常规填充规则。

15.10.  SOFTWARE
 
SOFTWARE属性包含发送消息的代理使用的软件的文本描述。
它由客户端和服务器使用。
它的价值应该包括制造商和版本号。
该属性对协议的操作没有影响，仅用作诊断和调试目的的工具。
SOFTWARE的值是可变长度。
它必须是一个小于128个字符的UTF-8 [RFC3629]编码序列（可以长达763个字节）。

15.11.  ALTERNATE-SERVER
 
   备用服务器表示一个备用传输地址，用于标识STUN客户端应尝试的不同STUN服务器。
   它的编码方式与MAPPED-ADDRESS相同，因此通过IP地址引用单个服务器。
   IP地址类型(ip4,ip6)必须与请求的IP地址相同。

16.  安全考虑因素
 
16.1.  攻击协议


16.1.1. 外部攻击


  攻击者可以尝试修改传输中的STUN消息
  导致STUN操作失败。 检测到这些攻击
  使用短期或长期凭证通过消息完整性机制进行请求和响应。 当然，一旦检测到，被操纵的数据包将被丢弃，导致STUN事务有效地失败。 只有路径上的攻击者才能进行此攻击。

   An attacker that can observe, but not modify, STUN messages in-
   transit (for example, an attacker present on a shared access medium,
   such as Wi-Fi), can see a STUN request, and then immediately send a
   STUN response, typically an error response, in order to disrupt STUN
   processing.  This attack is also prevented for messages that utilize
   MESSAGE-INTEGRITY.  However, some error responses, those related to
   authentication in particular, cannot be protected by MESSAGE-
   INTEGRITY.  When STUN itself is run over a secure transport protocol
   (e.g., TLS), these attacks are completely mitigated.
    
   Depending on the STUN usage, these attacks may be of minimal
   consequence and thus do not require message integrity to mitigate.
   For example, when STUN is used to a basic STUN server to discover a
   server reflexive candidate for usage with ICE, authentication and
   message integrity are not required since these attacks are detected
   during the connectivity check phase.  The connectivity checks
   themselves, however, require protection for proper operation of ICE
   overall.  As described in Section 14, STUN usages describe when
   authentication and message integrity are needed.

   Since STUN uses the HMAC of a shared secret for authentication and
   integrity protection, it is subject to offline dictionary attacks.
   When authentication is utilized, it SHOULD be with a strong password
   that is not readily subject to offline dictionary attacks.
   Protection of the channel itself, using TLS, mitigates these attacks.
   However, STUN is most often run over UDP and in those cases, strong
   passwords are the only way to protect against these attacks.

16.1.2.  内部攻击


   A rogue client may try to launch a DoS attack against a server by
   sending it a large number of STUN requests.  Fortunately, STUN
   requests can be processed statelessly by a server, making such
   attacks hard to launch.

   A rogue client may use a STUN server as a reflector, sending it
   requests with a falsified source IP address and port.  In such a
   case, the response would be delivered to that source IP and port.
   There is no amplification of the number of packets with this attack
   (the STUN server sends one packet for each packet sent by the
   client), though there is a small increase in the amount of data,
   since STUN responses are typically larger than requests.  This attack
   is mitigated by ingress source address filtering.

   Revealing the specific software version of the agent through the
   SOFTWARE attribute might allow them to become more vulnerable to
   attacks against software that is known to contain security holes.
   Implementers SHOULD make usage of the SOFTWARE attribute a
   configurable option.

16.2. 影响服务


   This section lists attacks that might be launched against a usage of
   STUN.  Each STUN usage must consider whether these attacks are
   applicable to it, and if so, discuss counter-measures.

   Most of the attacks in this section revolve around an attacker
   modifying the reflexive address learned by a STUN client through a
    
   Binding request/response transaction.  Since the usage of the
   reflexive address is a function of the usage, the applicability and
   remediation of these attacks are usage-specific.  In common
   situations, modification of the reflexive address by an on-path
   attacker is easy to do.  Consider, for example, the common situation
   where STUN is run directly over UDP.  In this case, an on-path
   attacker can modify the source IP address of the Binding request
   before it arrives at the STUN server.  The STUN server will then
   return this IP address in the XOR-MAPPED-ADDRESS attribute to the
   client, and send the response back to that (falsified) IP address and
   port.  If the attacker can also intercept this response, it can
   direct it back towards the client.  Protecting against this attack by
   using a message-integrity check is impossible, since a message-
   integrity value cannot cover the source IP address, since the
   intervening NAT must be able to modify this value.  Instead, one
   solution to preventing the attacks listed below is for the client to
   verify the reflexive address learned, as is done in ICE [MMUSIC-ICE].
   Other usages may use other means to prevent these attacks.

16.2.1.  Attack I: Distributed DoS (DDoS) against a Target


   In this attack, the attacker provides one or more clients with the
   same faked reflexive address that points to the intended target.
   This will trick the STUN clients into thinking that their reflexive
   addresses are equal to that of the target.  If the clients hand out
   that reflexive address in order to receive traffic on it (for
   example, in SIP messages), the traffic will instead be sent to the
   target.  This attack can provide substantial amplification,
   especially when used with clients that are using STUN to enable
   multimedia applications.  However, it can only be launched against
   targets for which packets from the STUN server to the target pass
   through the attacker, limiting the cases in which it is possible.

16.2.2.  Attack II: Silencing a Client


   In this attack, the attacker provides a STUN client with a faked
   reflexive address.  The reflexive address it provides is a transport
   address that routes to nowhere.  As a result, the client won't
   receive any of the packets it expects to receive when it hands out
   the reflexive address.  This exploitation is not very interesting for
   the attacker.  It impacts a single client, which is frequently not
   the desired target.  Moreover, any attacker that can mount the attack
   could also deny service to the client by other means, such as
   preventing the client from receiving any response from the STUN
   server, or even a DHCP server.  As with the attack in Section 16.2.1,
   this attack is only possible when the attacker is on path for packets
   sent from the STUN server towards this unused IP address.
    
16.2.3.  Attack III: Assuming the Identity of a Client


   This attack is similar to attack II.  However, the faked reflexive
   address points to the attacker itself.  This allows the attacker to
   receive traffic that was destined for the client.

16.2.4.  Attack IV: Eavesdropping


   In this attack, the attacker forces the client to use a reflexive
   address that routes to itself.  It then forwards any packets it
   receives to the client.  This attack would allow the attacker to
   observe all packets sent to the client.  However, in order to launch
   the attack, the attacker must have already been able to observe
   packets from the client to the STUN server.  In most cases (such as
   when the attack is launched from an access network), this means that
   the attacker could already observe packets sent to the client.  This
   attack is, as a result, only useful for observing traffic by
   attackers on the path from the client to the STUN server, but not
   generally on the path of packets being routed towards the client.

16.3.  Hash Agility Plan


   This specification uses HMAC-SHA-1 for computation of the message
   integrity.  If, at a later time, HMAC-SHA-1 is found to be
   compromised, the following is the remedy that will be applied.

   We will define a STUN extension that introduces a new message-
   integrity attribute, computed using a new hash.  Clients would be
   required to include both the new and old message-integrity attributes
   in their requests or indications.  A new server will utilize the new
   message-integrity attribute, and an old one, the old.  After a
   transition period where mixed implementations are in deployment, the
   old message-integrity attribute will be deprecated by another
   specification, and clients will cease including it in requests.

   It is also important to note that the HMAC is done using a key that
   is itself computed using an MD5 of the user's password.  The choice
   of the MD5 hash was made because of the existence of legacy databases
   that store passwords in that form.  If future work finds that an HMAC
   of an MD5 input is not secure, and a different hash is needed, it can
   also be changed using this plan.  However, this would require
   administrators to repopulate their databases.

17.  IAB Considerations


   The IAB has studied the problem of Unilateral Self-Address Fixing
   (UNSAF), which is the general process by which a client attempts to
   determine its address in another realm on the other side of a NAT
    
   through a collaborative protocol reflection mechanism (RFC3424
   [RFC3424]).  STUN can be used to perform this function using a
   Binding request/response transaction if one agent is behind a NAT and
   the other is on the public side of the NAT.

   The IAB has mandated that protocols developed for this purpose
   document a specific set of considerations.  Because some STUN usages
   provide UNSAF functions (such as ICE [MMUSIC-ICE] ), and others do
   not (such as SIP Outbound [SIP-OUTBOUND]), answers to these
   considerations need to be addressed by the usages themselves.

18.  IANA注意事项


   IANA创建了三个新的注册表：“STUN方法注册表”，“STUN属性注册表”和“STUN错误代码注册表”。 IANA还将STUN指定的IANA端口名称从“nat-stun-port”更改为“stun”。

18.1.  STUN Methods Registry


   A STUN method is a hex number in the range 0x000 - 0xFFF.  The
   encoding of STUN method into a STUN message is described in
   Section 6.

   The initial STUN methods are:

   0x000: (Reserved)
   0x001: Binding
   0x002: (Reserved; was SharedSecret)

   STUN methods in the range 0x000 - 0x7FF are assigned by IETF Review
   [RFC5226].  STUN methods in the range 0x800 - 0xFFF are assigned by
   Designated Expert [RFC5226].  The responsibility of the expert is to
   verify that the selected codepoint(s) are not in use and that the
   request is not for an abnormally large number of codepoints.
   Technical review of the extension itself is outside the scope of the
   designated expert responsibility.

18.2.  STUN Attribute Registry


   A STUN Attribute type is a hex number in the range 0x0000 - 0xFFFF.
   STUN attribute types in the range 0x0000 - 0x7FFF are considered
   comprehension-required; STUN attribute types in the range 0x8000 -
   0xFFFF are considered comprehension-optional.  A STUN agent handles
   unknown comprehension-required and comprehension-optional attributes
   differently.

   The initial STUN Attributes types are:
    
   Comprehension-required range (0x0000-0x7FFF):
     0x0000: (Reserved)
     0x0001: MAPPED-ADDRESS
     0x0002: (Reserved; was RESPONSE-ADDRESS)
     0x0003: (Reserved; was CHANGE-ADDRESS)
     0x0004: (Reserved; was SOURCE-ADDRESS)
     0x0005: (Reserved; was CHANGED-ADDRESS)
     0x0006: USERNAME
     0x0007: (Reserved; was PASSWORD)
     0x0008: MESSAGE-INTEGRITY
     0x0009: ERROR-CODE
     0x000A: UNKNOWN-ATTRIBUTES
     0x000B: (Reserved; was REFLECTED-FROM)
     0x0014: REALM
     0x0015: NONCE
     0x0020: XOR-MAPPED-ADDRESS

   Comprehension-optional range (0x8000-0xFFFF)
     0x8022: SOFTWARE
     0x8023: ALTERNATE-SERVER
     0x8028: FINGERPRINT

   STUN Attribute types in the first half of the comprehension-required
   range (0x0000 - 0x3FFF) and in the first half of the comprehension-
   optional range (0x8000 - 0xBFFF) are assigned by IETF Review
   [RFC5226].  STUN Attribute types in the second half of the
   comprehension-required range (0x4000 - 0x7FFF) and in the second half
   of the comprehension-optional range (0xC000 - 0xFFFF) are assigned by
   Designated Expert [RFC5226].  The responsibility of the expert is to
   verify that the selected codepoint(s) are not in use, and that the
   request is not for an abnormally large number of codepoints.
   Technical review of the extension itself is outside the scope of the
   designated expert responsibility.

18.3.  STUN Error Code Registry


   A STUN error code is a number in the range 0 - 699.  STUN error codes
   are accompanied by a textual reason phrase in UTF-8 [RFC3629] that is
   intended only for human consumption and can be anything appropriate;
   this document proposes only suggested values.

   STUN error codes are consistent in codepoint assignments and
   semantics with SIP [RFC3261] and HTTP [RFC2616].

   The initial values in this registry are given in Section 15.6.
    
   New STUN error codes are assigned based on IETF Review [RFC5226].
   The specification must carefully consider how clients that do not
   understand this error code will process it before granting the
   request.  See the rules in Section 7.3.4.

18.4.  STUN UDP and TCP Port Numbers


   IANA has previously assigned port 3478 for STUN.  This port appears
   in the IANA registry under the moniker "nat-stun-port".  In order to
   align the DNS SRV procedures with the registered protocol service,
   IANA is requested to change the name of protocol assigned to port
   3478 from "nat-stun-port" to "stun", and the textual name from
   "Simple Traversal of UDP Through NAT (STUN)" to "Session Traversal
   Utilities for NAT", so that the IANA port registry would read:

   stun   3478/tcp   Session Traversal Utilities for NAT (STUN) port
   stun   3478/udp   Session Traversal Utilities for NAT (STUN) port

   In addition, IANA has assigned port number 5349 for the "stuns"
   service, defined over TCP and UDP.  The UDP port is not currently
   defined; however, it is reserved for future use.

19.  Changes since RFC 3489


   This specification obsoletes RFC 3489 [RFC3489].  This specification
   differs from RFC 3489 in the following ways:

   o  Removed the notion that STUN is a complete NAT traversal solution.
      STUN is now a tool that can be used to produce a NAT traversal
      solution.  As a consequence, changed the name of the protocol to
      Session Traversal Utilities for NAT.

   o  Introduced the concept of STUN usages, and described what a usage
      of STUN must document.

   o  Removed the usage of STUN for NAT type detection and binding
      lifetime discovery.  These techniques have proven overly brittle
      due to wider variations in the types of NAT devices than described
      in this document.  Removed the RESPONSE-ADDRESS, CHANGED-ADDRESS,
      CHANGE-REQUEST, SOURCE-ADDRESS, and REFLECTED-FROM attributes.

   o  Added a fixed 32-bit magic cookie and reduced length of
      transaction ID by 32 bits.  The magic cookie begins at the same
      offset as the original transaction ID.
	   
   o  Added the XOR-MAPPED-ADDRESS attribute, which is included in
      Binding responses if the magic cookie is present in the request.
      Otherwise, the RFC 3489 behavior is retained (that is, Binding
      response includes MAPPED-ADDRESS).  See discussion in XOR-MAPPED-
      ADDRESS regarding this change.

   o  Introduced formal structure into the message type header field,
      with an explicit pair of bits for indication of request, response,
      error response, or indication.  Consequently, the message type
      field is split into the class (one of the previous four) and
      method.

   o  Explicitly point out that the most significant 2 bits of STUN are
      0b00, allowing easy differentiation with RTP packets when used
      with ICE.

   o  Added the FINGERPRINT attribute to provide a method of definitely
      detecting the difference between STUN and another protocol when
      the two protocols are multiplexed together.

   o  Added support for IPv6.  Made it clear that an IPv4 client could
      get a v6 mapped address, and vice versa.

   o  Added long-term-credential-based authentication.

   o  Added the SOFTWARE, REALM, NONCE, and ALTERNATE-SERVER attributes.

   o  Removed the SharedSecret method, and thus the PASSWORD attribute.
      This method was almost never implemented and is not needed with
      current usages.

   o  Removed recommendation to continue listening for STUN responses
      for 10 seconds in an attempt to recognize an attack.

   o  Changed transaction timers to be more TCP friendly.

   o  Removed the STUN example that centered around the separation of
      the control and media planes.  Instead, provided more information
      on using STUN with protocols.

   o  Defined a generic padding mechanism that changes the
      interpretation of the length attribute.  This would, in theory,
      break backwards compatibility.  However, the mechanism in RFC 3489
      never worked for the few attributes that weren't aligned naturally
      on 32-bit boundaries.

   o  REALM, SERVER, reason phrases, and NONCE limited to 127
      characters.  USERNAME to 513 bytes.
	   
   o  Changed the DNS SRV procedures for TCP and TLS.  UDP remains the
      same as before.

 
 
   